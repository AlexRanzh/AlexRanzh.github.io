<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Introduction to Machine Learning</title>
      <link href="/2019/04/16/Introduction%20to%20Machine%20Learning/"/>
      <url>/2019/04/16/Introduction%20to%20Machine%20Learning/</url>
      
        <content type="html"><![CDATA[<p>This note is based on 2019 Spring COMPSCI189/289A course at University of California, Berkeley by Jonathan Shewchuk.</p><p>#Supervised Learning</p><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><h3 id="example-1-classify-digit-1-and-7"><a href="#example-1-classify-digit-1-and-7" class="headerlink" title="example 1: classify digit 1 and 7"></a>example 1: classify digit 1 and 7</h3><ol><li>$N\times N$ pixels matrices</li><li>flatten into vector</li><li>create a classifier for $N\times N$ space<br>Note: Decision Boundary is a hyperplane</li></ol><h3 id="example-2-Bank-loan-default-prediction"><a href="#example-2-Bank-loan-default-prediction" class="headerlink" title="example 2: Bank loan default prediction"></a>example 2: Bank loan default prediction</h3><p>See notes for M3S17<a href>Quantitative Methods for Finance</a></p><h3 id="Feature-Independent-Variables-Predictor-Variables"><a href="#Feature-Independent-Variables-Predictor-Variables" class="headerlink" title="Feature/Independent Variables/ Predictor Variables"></a>Feature/Independent Variables/ Predictor Variables</h3><p>?</p><h3 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h3><p>The model is shaped to specifically to one certain data set so not predictive to new data.</p><p>When the test error worse coz the classifier becomes too sensitive to outliers or to other spurious/untrue patterns.</p><p>Sinuous decision boundaries that fit the sample points so well that it do not classify future points well.</p><h4 id="Quantify-Overfitting"><a href="#Quantify-Overfitting" class="headerlink" title="Quantify Overfitting"></a>Quantify Overfitting</h4><h3 id="Decision-Boundary"><a href="#Decision-Boundary" class="headerlink" title="Decision Boundary"></a>Decision Boundary</h3><p>The boundary chosen by classifier to separate items in class from those are not.</p><h3 id="Decision-Function"><a href="#Decision-Function" class="headerlink" title="Decision Function"></a>Decision Function</h3><p>A function $f(x)$ that maps a sample point to a scalar value that<br>$$<br>f(x)&gt;0 if x \in class C<br>f(x)\leq if x not \in class C<br>$$</p><p>For these decision function, the decision boundary is $f(x)=0$, <strong>usually</strong> a (d-1) dimensional surface in $R^d$.</p><h3 id="Isosurface-iso-contours"><a href="#Isosurface-iso-contours" class="headerlink" title="Isosurface/iso contours"></a>Isosurface/iso contours</h3><p>A isosurface for function $f$ is ${x: f(x)=0}$, 0 is isovalue here.<br>Note: ‘iso-‘ prefix means ‘equal-‘</p><h3 id="Linear-classifier"><a href="#Linear-classifier" class="headerlink" title="Linear classifier"></a>Linear classifier</h3><p>The decision boundary is a line/plane<br>Usually a linear decision function.</p><p>$$<br>x=(x_1,x_2,…,x_5)^T</p><p>$$</p><h3 id="Conventions"><a href="#Conventions" class="headerlink" title="Conventions:"></a>Conventions:</h3><p>Uppercase roman: matrix, random variables, set<br>Lowercase roman: vector<br>Greek: scalar<br>Other scalar:</p><ul><li>n, number of sample points</li><li>d, number of features</li><li>i,j,k, integer indices<br>Function: f(), s(),…</li></ul><h3 id="Norms"><a href="#Norms" class="headerlink" title="Norms"></a>Norms</h3><ul><li>Euclidean norms</li><li>Normalize a vector: $\frac{x}{|x|}$</li><li>dot product:<ul><li>length:$|x|=\sum x_i y_i$</li><li>angle: $cos(\theta)=\frac{x\dot y}{|x||y|}$</li></ul></li></ul><h3 id="hyperplane"><a href="#hyperplane" class="headerlink" title="hyperplane"></a>hyperplane</h3><p>Given a decision function $f(x)=w\dot x+\alpha$ is $H={x: w\dot x =-\alpha }$<br>The set H is a <strong>hyperplane</strong>.</p><p><strong>property</strong><br>For any x, y on H, $w\dot(y-x)=0$</p><p><strong>normal vector</strong> w</p><p><strong>signed distance</strong>$w\dot x +\alpha$, $w$ is unit vector<br>i.e. positive on one side of H, negative on the other side</p><p>Note: the distance from H to the origin is $\alpha$.<br>Note2: $\alpha =0$ iff H passes through origin</p><h3 id="weights"><a href="#weights" class="headerlink" title="weights"></a>weights</h3><p>coefficients in $w$ and$\alpha$ are called <strong>weights</strong> or <strong>regression coefficients</strong></p><h3 id="Linearly-separable"><a href="#Linearly-separable" class="headerlink" title="Linearly separable"></a>Linearly separable</h3><p>the input data is <strong>linearly separable</strong> if there exists a hyperplane that separates all the sample planes in C from those not in C.</p><h3 id="Centriod-classifier"><a href="#Centriod-classifier" class="headerlink" title="Centriod classifier"></a>Centriod classifier</h3><p>computer mean $\mu_c$ of all vectors in class C and meam $\mu_x$ of al vectors NOT in class C.</p><ul><li>Decision function:<br>$f(x)=(\mu_c-\mu_x)\dot x-(\mu_c-\mu_x)\dot \frac{(\mu_c-\mu_x)}{2}$<br>$(\mu_c-\mu_x)$ is normal vector<br>$\frac{(\mu_c-\mu_x)}{2}$ is midpoint between$\mu_c, \mu_x$<br>so the decision boundary is the hyperplane that bisects \bar{\mu_c\mu_x}</li><li>good at: classify with samples from two gaussian/normal distributions, especially when sample size is large</li></ul><h3 id="Perceptron-Algorithm"><a href="#Perceptron-Algorithm" class="headerlink" title="Perceptron Algorithm"></a>Perceptron Algorithm</h3><blockquote><p>Slow but correct for linearly separable points.<br>Uses a <strong>numerical optimisation</strong> algorithm, namely the <strong>gradient decent</strong>.</p></blockquote><p>Sample points $X_1,X_2,…,X_n$.<br>For each sample point, $y_i = 1(\in C)\ or\ -1(\notin C)$</p><p>For simplicity, assume the decision boundaries pass through the origin.</p><h2 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h2><p>#Unsupervised Learning</p><h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2><h2 id="Dimensionality-Reduction"><a href="#Dimensionality-Reduction" class="headerlink" title="Dimensionality Reduction"></a>Dimensionality Reduction</h2><h1 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h1><p>Hold back a subset of training data for future test use–validation set(to tune hyperparameters/choose model).</p><p>test set: final evaluation</p><ol><li>train a classifier multiple times, with different model/hyperparameter</li><li>test it on NEW data</li><li>choose the setting that gives the best validation result<br>?why: we want the model to be working in general data. In most cases(knn for example),input used data will always give the right output, which is not valuable for our evaluation of the model.</li></ol><h2 id="Types-of-error"><a href="#Types-of-error" class="headerlink" title="Types of error"></a>Types of error</h2><ol><li>training set error: fraction of training images not classified correctly</li><li>test set error:<br>fraction of misclassifying new data</li></ol><h1 id="outlier"><a href="#outlier" class="headerlink" title="outlier:"></a>outlier:</h1><p>points are atypical</p><h1 id="hyperparameters"><a href="#hyperparameters" class="headerlink" title="hyperparameters"></a>hyperparameters</h1><p>~ control overfitting/underfitting(e.g. k in knn)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/14/hello-world/"/>
      <url>/2019/04/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><p><img src="/photos/1.png" alt></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><img src="https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png" alt></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Quantitative Methods in Retail Finance Note 4</title>
      <link href="/2019/04/14/Quantitative%20Methods%20in%20Retail%20Finance%20Note4/"/>
      <url>/2019/04/14/Quantitative%20Methods%20in%20Retail%20Finance%20Note4/</url>
      
        <content type="html"><![CDATA[<p>This notes follows materials from the slides for M3S17 at Imperial College London Mathematics Department by Dr. Tony Bellotti. Questions mentioned are referring to past exam papers of M3S17 at Imperial College London.</p><p>#Chapter 3: Markov Transition Model</p><h2 id="Markov-Transition-Models"><a href="#Markov-Transition-Models" class="headerlink" title="Markov Transition Models"></a>Markov Transition Models</h2><h3 id="Why-Markov-Chain-Model"><a href="#Why-Markov-Chain-Model" class="headerlink" title="Why Markov Chain Model?"></a>Why Markov Chain Model?</h3><p>This model allow us to track model <strong>changes in the state</strong> of an account over time.<br>e.g. Tracking credit card use.</p><h3 id="First-order-Markov-Transition-Model"><a href="#First-order-Markov-Transition-Model" class="headerlink" title="First-order Markov Transition Model"></a>First-order Markov Transition Model</h3><ul><li>Let $(X_1, X_2, …, X_n)$ be a sequence of discrete random variables that take value from ${1,2,…,K}$ with K fixed.</li><li><strong>first-order finite value Markov chain</strong><br>The sequence is said to be a <em>first-order finite value Markov chain</em> if<br>$$<br>P(X_{n+1}=j|X_0=x_0,X_1=x_1,X_2=x_2,…,X_{n-1}=x_{n-1},X_n = i) = P(X_{n+1}=j|X_n = i)<br>$$<br>for all $n, x_0,x_1, …, x_{n-1}$ and $i,j$ such that $1\leq i,j \leq K$.</li><li><strong>transition probability</strong><br><em>Transition probability</em> $p_n$ is defined as<br>$$<br>p_{n}(i,j)=P(X_n=j|X_{n-1}=i)<br>$$</li><li><strong>transition matrix</strong><br><em>Transition matrix</em> $P$ is defined as a $K \times K$ matrix such that<br>$$<br>P_n[i,j] = p_{n}(i,j)<br>$$</li><li><strong>structural zeroes</strong><br>If it is certain that no transition will be made from i to j in the $n$th period, then set $p_n(i,j)=0$, this is called a <em>structural zero</em>.</li></ul><p>###Propagation of Markov Chain<br>If we know the transition matrix from period $n-r$ to $n$, i.e. $P_r,P_{r+1},…,P_{n-1}$ are known, then we also be able to know the state in the $n$th period:<br>$$<br>Prob(X_{n}=j|X_{n-r}=i) = P_{n-r+1}P_{n-r+2}…P_{n}[i,j]<br>$$<br>for any $1\leq r \leq n$</p><p>Forcasting from state 0:<br>$$<br>Prob(X_{n}=j|X_{0}=i) = P_{1}P_{2}…P_{n}[i,j]<br>$$<br>let $\pi_{i}$ be the marginal distribution for $X_n$:<br>$$\pi_n = (P(X_n = 1),P(X_n = 2),…,P(X_n = K))^T$$</p><p>Then,<br>$$\pi_n = \pi_0(P_1 P_2 … P_n)$$</p><h3 id="Stationary-Markov-Chain"><a href="#Stationary-Markov-Chain" class="headerlink" title="Stationary Markov Chain"></a>Stationary Markov Chain</h3><ul><li><strong>stationary</strong><br>A Markov chain is <em>stationary</em> if $p_n(i,j)=p(i,j)$ for all $<strong>n</strong>,\ and\ i,j\ where 1\leq i, j \leq K$, for some transition probability $p$.</li><li><strong>stationary distribution</strong><br>A <em>stationary distribution</em> for transition matrix is a distribution $\pi^\star = \pi^\star P$.<blockquote><p>In practice, most Markov chains converge (with 𝑛) to a stationary<br>distribution.<br>(Markov chains which have a periodicity in state change do not necessarily converge, but we do not cover this material in this course).</p></blockquote></li></ul><h2 id="Estimation"><a href="#Estimation" class="headerlink" title="Estimation"></a>Estimation</h2><p>The aim this section, given some data, is to estimate $\mathbf{\theta}=(\theta_{ij})^{K}<em>{i,j=1}$ where $\theta</em>{ij}=p(i,j)$.<br>Maximum likelihood estimator for $\mathbf{\theta}$:<br>$$<br>\hat\theta_{ij}=\hat p(i,j)=\frac{n_{ij}}{\sum_{l=1}^{n}n_{il}}<br>$$<br>where $n_{ij}=|{t:x_{t-1}=i,x_{t}=j,\ for \ t\in {1,2,…,n}}|$, i.e. total number of observations that move from state $i$ to state $j$ during period 1 to n.<br><strong>proof</strong></p><blockquote><p>2017Q1<br>(c) Derive the maximum likelihood estimator for the first order finite-valued Markov transition model, assuming stationarity.</p></blockquote><ol><li>likelihood function</li></ol><p>$P(X_0=x_0,X_1=x_1,…,X_n=x_n)$<br>$=\prod_{t=1}^{n} P(X_{t}=x_t|X_{t-1}=x_{t-1},X_{t-2}=x_{t-2},…,X_{1}=x_{1})P(X_0=x_0)$<br>$=\prod_{t=1}^{n} P(X_{t}=x_t|X_{t-1}=x_{t-1})P(X_0=x_0)(Chain rule)$<br>$=P(X_0=x_0)\prod_{t=1}^{n} P(X_{t}=x_t|X_{t-1}=x_{t-1})$<br>$=P(X_0=x_0)\prod_{i=1}^{n}\prod_{j=1}^{n}[p(i,j)]^{n_{ij}}$<br>$=P(X_0=x_0)\prod_{i=1}^{n}\prod_{j=1}^{n}[\theta_{ij}]^{n_{ij}}$<br>$$<br>where\ n_{ij}=|{t:x_t=x_t,X_{t-1}=x_{t-1},\ for\ t\in {1,…,n}}|<br>$$</p><ol start="2"><li>log likelihood function</li><li>differentiate and find MLE</li><li>adjust to constraints  </li></ol><h2 id="Testing-First-order-Assumptions"><a href="#Testing-First-order-Assumptions" class="headerlink" title="Testing First-order Assumptions"></a>Testing First-order Assumptions</h2><p>In order to test if first order markov chain is a suitable assumption in each occasion,<br>we use chi-square hypothesis test.</p><h3 id="second-order-Markov-chain"><a href="#second-order-Markov-chain" class="headerlink" title="second order Markov chain"></a>second order Markov chain</h3><p>A sequence (x_1,..,x_n) is a <em>second order Markov chain</em> if<br>$P(x_n+1=j|X_0=x_0,…,X_{n-1}=k,X_{n}=i)=P(x_n+1=j|X_{n-1}=k,X_{n}=i)$</p><p>The <strong>transition probability</strong><br>$p_n(k,i,j)=P(X_n=i, X_{n-1}=k)$</p><p>The <strong>MLE for a second-Markov chain</strong> can similarly be proved as:<br>$\hat p(k,i,j)=\hat\theta_{kij}=\frac{n_kij}{mki}$<br>where $n_{kij}=|{t:x_{t-2}=k,x_{t-1}=i,x_{t}=j\ for\ t \in {2,…,n}}|,<br>m_{ki}=|{t:x_{t-2}=k,x_{t-1}=i\ for\ t \in {2,…,n}}|=\sum_{l=i}^{n}n_{kil}$</p><ol><li><p><strong>$H_{0}$</strong><br>Null hypothesis:<br>$P(1,i,j)=P(2,i,j)=…=P(K,i,j)=P(i,j)$<br>where $P(k,i,j)$ is second-order Markov transition probability from state k to i then to j.</p></li><li><p><strong>$n_k$</strong><br>$n_k=|{t:x_t=k\ for\ t \in {1,..,n}}|$<br>i.e. The observed number of times for each states</p></li><li><p><strong>$O_{kj}$</strong><br>The observed number of times state k follwed by i and then j<br>$O_{kj}=n{kij}=m_{ki}\hat p(i,j)$</p></li><li><p><strong>$E_{kj}$</strong><br>The expected number of times state $k$ is followed by state $i$ and then $j$, <strong>given null hypothesis</strong> is:<br>$E_{kj}=n_{k}\hat p(k,i)\hat p(i,j)\approx m_{ki}\hat p(i,j)$<br>becuase $\hat p(k,i)=\frac{n_{ki}}{\sum_{l=1}^{K}n_{kl}}\approx \frac{m_{ki}}{n_k}$</p></li><li><p><strong>Pearson Chi_square test</strong><br>$$<br>\chi^2 = \sum_{k\in S_1}\sum_{k\in S_2}\frac{(O_{kj}-E{kj})^2}{E_{kj}}<br>$$</p></li></ol><ul><li>S1 is the set of states which do not have a structural zero moving to state $i$</li><li>S2 is the set of states which do not have a structural zero moving from state $i$</li></ul><ol start="6"><li><strong>Degree of freedom</strong><br>$df = (K-1-z_{1})(K-1-z_{2})$</li></ol><ul><li>$z_1$: the number of structural zeroes in the transition from $k$ to $i$.</li><li>$z_2$: the number of structural zeroes in the transition from $i$ to $j$.</li></ul><h2 id="Roll-rate-Model"><a href="#Roll-rate-Model" class="headerlink" title="Roll-rate Model"></a>Roll-rate Model</h2>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Math Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Credit Modelling </tag>
            
            <tag> Markov Transition Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quantitative Methods in Retail Finance Note 3</title>
      <link href="/2019/04/14/Quantitative%20Methods%20in%20Retail%20Finance%20Note3/"/>
      <url>/2019/04/14/Quantitative%20Methods%20in%20Retail%20Finance%20Note3/</url>
      
        <content type="html"><![CDATA[<p>This notes follows materials from the slides for M3S17 at Imperial College London Mathematics Department by Dr. Tony Bellotti. Questions mentioned are referring to past exam papers of M3S17 at Imperial College London.</p><h1 id="Chapter-2-Survival-Models-for-Credit-Risk"><a href="#Chapter-2-Survival-Models-for-Credit-Risk" class="headerlink" title="Chapter 2: Survival Models for Credit Risk"></a>Chapter 2: Survival Models for Credit Risk</h1>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Math Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Survival Model </tag>
            
            <tag> Credit Modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quantitative Methods in Retail Finance Note 2</title>
      <link href="/2019/04/14/Quantitative%20Methods%20in%20Retail%20Finance%20Note2/"/>
      <url>/2019/04/14/Quantitative%20Methods%20in%20Retail%20Finance%20Note2/</url>
      
        <content type="html"><![CDATA[<p>This notes follows materials from the slides for M3S17 at Imperial College London Mathematics Department by Dr. Tony Bellotti. Questions mentioned are referring to past exam papers of M3S17 at Imperial College London.</p><h1 id="Chapter-8-Artificial-Neural-Networks-in-Fraud-detection"><a href="#Chapter-8-Artificial-Neural-Networks-in-Fraud-detection" class="headerlink" title="Chapter 8: Artificial Neural Networks in Fraud detection"></a>Chapter 8: Artificial Neural Networks in Fraud detection</h1><p>##</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Math Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quantitative Method in Retail Finance Note 1</title>
      <link href="/2019/04/13/Quantitative%20Methods%20in%20Retail%20Finance%20Notes1/"/>
      <url>/2019/04/13/Quantitative%20Methods%20in%20Retail%20Finance%20Notes1/</url>
      
        <content type="html"><![CDATA[<p>This notes follows materials from the slides for M3S17 at Imperial College London Mathematics Department by Dr. Tony Bellotti. Questions mentioned are referring to past exam papers of M3S17 at Imperial College London.</p><h1 id="Chapter-7-Fraud-Detection-in-Retail-Credit"><a href="#Chapter-7-Fraud-Detection-in-Retail-Credit" class="headerlink" title="Chapter 7: Fraud Detection in Retail Credit"></a>Chapter 7: Fraud Detection in Retail Credit</h1><h2 id="Types-of-Fraud"><a href="#Types-of-Fraud" class="headerlink" title="Types of Fraud:"></a>Types of Fraud:</h2><ul><li>Theft</li><li>Counterfeit</li><li>Application</li><li>Card-not-present/online</li></ul><h2 id="Automated-Fraud-Detection"><a href="#Automated-Fraud-Detection" class="headerlink" title="Automated Fraud Detection"></a>Automated Fraud Detection</h2><p>This essentially is a classification problem, legitimate transaction Y=1, illegal Y=0.</p><p><strong>Special problems for fraud detection (that distinguish it from other classification problems)</strong></p><blockquote><p>2017 Q3(a) What special characteristics does fraud detection have, considered as a classification problem?<br>∗ Need to process millions of transactions in real time.<br>∗ Highly imbalanced classification problem: ratio of fraudulent to legitimate<br>transactions is typically very small.<br>∗ Nature of fraud is reflexive. That is, fraudsters adapt to the detection methods applied by banks to stop them.</p></blockquote><ol><li>High volume data.</li><li>Data highly imbalanced.</li><li>Reflexive nature.</li></ol><p><em>difference of fraud detection problem from application model?</em><br>  Do not need to explain the model, so nonlinear complicated models are allowed.</p><h2 id="Business-Rule-method"><a href="#Business-Rule-method" class="headerlink" title="Business Rule method"></a>Business Rule method</h2><blockquote><p>For example, the card is used abroad<br>and it had not been used in the past year in the country<br>and the card holder did not tell the bank they will be abroad</p></blockquote><h2 id="Predictive-Model-method"><a href="#Predictive-Model-method" class="headerlink" title="Predictive Model method"></a>Predictive Model method</h2><p>Construct a two-class classifier - a fraud scorecard.</p><ul><li>the higher the score, the more trustworthy the account is.</li><li>classifier model with function $f$: $\hat{y} = f(x,\theta)$, and estimate $\theta$ with data x.</li><li>filter out some legitimate transaction to balance training data set. e.g. discard small amount transactions, regular transactions and inactive accounts.<br><strong>past research have shown that a linear model is not enough, non-linear classifiers like ANN works better.</strong></li><li>This method works well in detecting known type fraudulent transactions, but not able to deal with new fraud types.</li></ul><h2 id="Anomaly-Detection-method"><a href="#Anomaly-Detection-method" class="headerlink" title="Anomaly Detection method"></a>Anomaly Detection method</h2><p>Another method is to model only the legal transactions and detect any abnormal new transactions.</p><h3 id="Comparing-with-predictive-modelling"><a href="#Comparing-with-predictive-modelling" class="headerlink" title="Comparing with predictive modelling:"></a>Comparing with predictive modelling:</h3><p>  pros:</p><ol><li>it can detect new types of fraud</li><li>it do not worry about the imbalanced data(coz 1)<br>con:</li><li>it is not as sensible to transactions that are similar to legitimate ones</li></ol><h3 id="One-class-classifier-only-model-legitimate-pdf-over-predictor-variables"><a href="#One-class-classifier-only-model-legitimate-pdf-over-predictor-variables" class="headerlink" title="One-class classifier only model legitimate pdf over predictor variables"></a>One-class classifier only model legitimate pdf over predictor variables</h3><blockquote><p>2017Q3(b) What are the key differences between one-class and two-class classifiers for fraud?<br>∗ Two-class classifiers are modelling the difference between fraudulent and legitimate transactions.<br>∗ One-class classifiers just model distribution of legitimate transactions.<br>∗ One-class classifiers are well-suited to deal with the reflexivity of fraud, since they do not explicitly model the existing pattern of fraud.</p></blockquote><h3 id="Steps-for-Anomaly-Detection"><a href="#Steps-for-Anomaly-Detection" class="headerlink" title="Steps for Anomaly Detection:"></a>Steps for Anomaly Detection:</h3><ol><li>drop out abnormal transactions: fraudulent transactions, errors, genuine but outliers</li><li>Let $S = (\mathbf{x_{1}},\mathbf{x_{2}},…,\mathbf{x_{n}})$ be a training sequence of legitimate transactions.</li><li>estimate $f(\mathbf{x}|S,\gamma)$ where $\gamma$ is an estimation parameter.</li><li>A classification decision is made with a new observation $\mathbf{x_{new}}$ at:<br>$$<br>\hat(y) = I(f(\mathbf{x_{new}}|S,\gamma)&gt;\theta)<br>$$<br>where $\theta$ is a threshold in probability.<blockquote><p>2017Q3(e) Which of these will register a fraud alert, based on your result in part (d)?<br>ANS: T2 and T3 have density less than θ = 0.05 and so will register a fraud alert.</p></blockquote></li></ol><p><em>The threshold $\theta$ is manually set based on the (sensible) strategy of controlling the fraction $\epsilon$ of legitimate cases to be classified as anomalous, based on training data.</em><br>—- This is constrained by how many false alert is generated/business resource can be input to followups.</p><blockquote><p>2017 Q3(d) Given a false alarm rate ε = 1/8, and based only on this data, what is the value of θ?<br>ANS:<br>Use formula $$<br>max \theta s.t. \sum^{n}_{i=1}I(f(x_i) &gt; \theta) \leq n(1 − \epsilon)$$<br>where $$n(1 − \epsilon) = 24 × 7/8 = 21$$<br>Therefore, count lowest (24 − 21) = 3 densities from the table gives $\theta$ = 0.05.</p></blockquote><p>i.e.<br>$$<br>min\theta s.t.  \sum_{i=1}^{n}I(f(\mathbf{x}_{i}|S,\gamma)&gt;\theta)=floor(n\epsilon)<br>$$</p><h3 id="Kernel-Density-Estimator"><a href="#Kernel-Density-Estimator" class="headerlink" title="Kernel Density Estimator"></a>Kernel Density Estimator</h3><p>Crude empirical density:<br>$$<br>\hat{F_{EMP}}= \frac{1}{n}\sum_{i=1}^{n}I(x_{i}\leqslant x)<br>$$</p><p>kernel density function:</p><blockquote><p>2017Q3(c) Describe Parzen density estimation.</p></blockquote><p>$$<br>\hat{f(x)} = \frac{1}{nh^m}\sum_{i=1}^{n} K(\frac{x-x_{i}}{h})<br>$$s.t.</p><ol><li>$K(z) = K(-z)$</li><li>$\int K(z) dz = 1$</li><li>$\mathbf{x_1}, \mathbf{x_2}, …, \mathbf{x_n}$ is observations with dimension m</li><li>h is bandwidth constant</li></ol><h3 id="Available-data"><a href="#Available-data" class="headerlink" title="Available data"></a>Available data</h3><ul><li>Account Data</li><li>Transaction Data</li><li>Personal Data</li><li>Location data</li></ul><h2 id="Social-Network-Analysis"><a href="#Social-Network-Analysis" class="headerlink" title="Social Network Analysis"></a>Social Network Analysis</h2><p>Using weight $w_{ij}$ to estimate <strong>association feature/degree of connectedness to fraud people</strong> $F_{i}$ and hence have fraud propensity from it.</p><blockquote><p>2017Q3(f) Describe in words what Fi is measuring?<br>(f) Variable $F_{i}$ measures the degree of connectedness to other people committing fraud.</p></blockquote><h3 id="Formula"><a href="#Formula" class="headerlink" title="Formula:"></a>Formula:</h3><p>$$<br>F_{i} = \frac{1}{\sum_{i=1}^{n}w_{ij}} \sum_{j=1}^{n} w_{ij}p_{j}<br>$$</p><blockquote><p>2017Q3(g) What range of values can Fi take?<br>$0\leq F_i \leq 1$</p></blockquote><blockquote><p>2017Q3(h) Calculate the value of Fi for T4 (node 3)?<br>Use formula in the question to get (4 + 1)/(2 + 4 + 1 + 1) = 5/8 = 0.625.</p></blockquote><blockquote><p><strong>2017Q3(i) How are values of Fi broadly affecting the density?</strong><br>(i)<br>Low values of $F_i$ are inducing a small <strong>increase</strong> in density.<br>High values of $F_i$ are inducing a large <strong>decrease</strong> in density.<br><strong>Low density means default</strong></p></blockquote><h2 id="Model-Evaluation"><a href="#Model-Evaluation" class="headerlink" title="Model Evaluation"></a>Model Evaluation</h2><p>Special performance evaluation for this problem:</p><ol><li>proportion fraud detected</li><li>keep low false alarm rate, not to upset customer</li><li>cost monitoring automated fraud alert</li></ol><h3 id="Receiver-operating-characteristics-ROC"><a href="#Receiver-operating-characteristics-ROC" class="headerlink" title="Receiver-operating characteristics (ROC)"></a>Receiver-operating characteristics (ROC)</h3><p>Two CDF measures:<br>$$y = {0,1}  F_{y}(c)=P(S\leq c|Y=y)$$</p><ul><li>y=0: given a threshold c, probability of fraud transaction that identified as fraud)</li><li>y=1: given a threshold c, probability of false alert generated</li></ul><h3 id="Area-under-ROC-curve-AUC"><a href="#Area-under-ROC-curve-AUC" class="headerlink" title="Area under ROC curve(AUC)"></a>Area under ROC curve(AUC)</h3><p>$$<br>A = \int F_{1}(c)F_{0}’(c)dc<br>$$</p><h3 id="Precision-Recall-and-alarm-rate"><a href="#Precision-Recall-and-alarm-rate" class="headerlink" title="Precision, Recall and alarm rate"></a>Precision, Recall and alarm rate</h3><ul><li>$F(c) = P(S\leq c)$</li><li>$p_{0} = P(Y=0)$</li><li>Recall: $F_{0}(c)$, the proportion of fraud transactions that are detected</li><li>Precision: the proportion alerts that are actually fraud<br>$P(Y=0|S\leq c)=\frac{F_{0}(c)p_0}{F(c)}$</li><li>Alarm rate: $F(c)= p_0 \frac{recall}{precision}$, unconditional probability of alarm<br><strong>Monitoring cost increases linear with alarm rate</strong></li></ul><h3 id="Precision-recall-PR-curve"><a href="#Precision-recall-PR-curve" class="headerlink" title="Precision-recall (PR) curve"></a>Precision-recall (PR) curve</h3><p>properties:</p><ul><li>typical decreasing</li><li>best: 1,1</li><li>worst: $F(c)=F_0 (c)$, horizontal line with $precision =p_0$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> Math Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANN </tag>
            
            <tag> Credit modelling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DS100&amp;More - Data Manipulation and Cleaning</title>
      <link href="/2019/04/06/DS100%20-%20Data%20Manipulation%20and%20Cleaning/"/>
      <url>/2019/04/06/DS100%20-%20Data%20Manipulation%20and%20Cleaning/</url>
      
        <content type="html"><![CDATA[<p>This is the first section for my study note: DS100&amp;More, which records some useful points in data ETL(Extract, Transform and Loaded), visualisation, and modelling. The motivation is to keep a record of my second learning of UC Berkeley DS100 course:  Principles and Techniques of Data Science. By learning relative knowledge, reader should be familiar with some python tools that are in use now, as well as making some inferences from data by hand.</p><p>Please contact me at <a href="mailto:zr116@ic.ac.uk" target="_blank" rel="noopener">zr116@ic.ac.uk</a> for any correction and improvement, general discussion on data science is also welcome.</p><h3 id="Today’s-Objectives"><a href="#Today’s-Objectives" class="headerlink" title="Today’s Objectives"></a>Today’s Objectives</h3><ol><li>EDA(Exploratory Data Analysis)</li><li>Use pyhton Pandas to do EDA</li></ol><h3 id="Tabular-Data"><a href="#Tabular-Data" class="headerlink" title="Tabular Data"></a>Tabular Data</h3><p><a href="https://www.textbook.ds100.org/ch/03/pandas_intro.html" target="_blank" rel="noopener">DS100 Textbook: Tabular Data</a></p><p>The first thing to do when we have a new data set in hand is to look at its inside. Data can be structured in different ways:<br>1.1 Comma-Separated Values (CSV)<br>[example]<br>1.2 Tab-Separated Values (TSV)<br>2.1 JavaScript Object Format (JSON)<br>[curly brackets]<br>3.1 eXtensible Markup Language (XML)<br>[how websites store info]<br>3.2 HyperText Markup Language (HTML)</p><blockquote><p>CSV and TSV data is structured in a tabular structure, in rows and columns.<br>JSON, XML, HTML data has a hierarchical structure, like a tree.<br>(see Hokodo intern note for JSON processing methods)</p></blockquote><p>Check file format:</p><ol><li>right click and view profile</li><li>fancier way:<br>use command-line interface (CLI) tools/terminal<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure></li></ol><p>or if you are in Jupyter notebook:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!ls</span><br></pre></td></tr></table></figure></p><blockquote><p>!+command line in Jupyter</p></blockquote><p>Although all these data formats are often used, CSV is often the easiest and most frequently used structure.</p><p>Before reading data, need to figure out how much memory it is going to take.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!ls -l -h folder</span><br><span class="line">!du -h folder</span><br><span class="line">#specific file usage</span><br><span class="line">!du -sh folder/*</span><br></pre></td></tr></table></figure><p>As a rule of thumb, reading in a file of x GB requires 4x GB memory. <code>Pandas</code> needs 2x but has to share memory with other programs.</p><blockquote><p><strong>Memory Overhead</strong><br>Note that memory is shared by all programs running on a computer, including the operating system, web browsers, and yes, Jupyter notebook itself. A computer with 4 GiB total RAM might have only 1 GiB available RAM with many applications running. With 1 GiB available RAM, it is unlikely that <code>pandas</code> will be able to read in a 1 GiB file.</p></blockquote><ul><li>To view CSV data in python:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(&apos;&apos;)</span><br></pre></td></tr></table></figure><ul><li>How many rows and columns:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.shape</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Check the size of data before inpecting it to avoid printing too many columns, which is not helpful to getting to konw the data.</p></blockquote><ul><li><p>Total size:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.size</span><br></pre></td></tr></table></figure></li><li><p>Inspecting important statistical values of numerical variables in a data set:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure></li></ul><p>This returns count, mean, standard deviation, min, max, and quartiles. <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.describe.html" target="_blank" rel="noopener">Details</a></p><ul><li><p>inspect first/last several rows(default 5)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.head(5)#first 5</span><br><span class="line">data.tail(3)#last 3</span><br></pre></td></tr></table></figure></li><li><p>other common command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#set &apos;col_name&apos; column as index column, in_place replace the old index column</span><br><span class="line">data.set_index(&apos;col_name&apos;, in_place = True)</span><br><span class="line"></span><br><span class="line">#list all column names</span><br><span class="line">data.columns</span><br><span class="line"></span><br><span class="line">#selection</span><br><span class="line">##select entries in column &apos;col1&apos;</span><br><span class="line">data[&apos;col1&apos;]</span><br><span class="line">##select two columns: col1, col2</span><br><span class="line">data[[&apos;col1&apos;,&apos;col2&apos;]]</span><br><span class="line">##make selected part into a DataFrame</span><br><span class="line">data[[&apos;col1&apos;,&apos;col2&apos;]].to_frame()</span><br><span class="line">##select rows that has val1 in col1</span><br><span class="line">data[data[&apos;col1&apos;]==val1]</span><br><span class="line"></span><br><span class="line">#column manipulation</span><br><span class="line">##count number of each value in a column</span><br><span class="line">data[&apos;col1&apos;].value_count()</span><br><span class="line">##print unique values in a column</span><br><span class="line">data[&apos;col1&apos;].unique()</span><br><span class="line">##statistical values of a column</span><br><span class="line">data[&apos;col1&apos;].min()</span><br><span class="line">data[&apos;col1&apos;].max()</span><br><span class="line">data[&apos;col1&apos;].median()</span><br><span class="line"></span><br><span class="line">#locator</span><br><span class="line">data.loc[row_list,col_list]</span><br><span class="line">data.iloc[[row_index],[column_index]]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> DS Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Science </tag>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
            <tag> Data Cleaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallel Computing with Fortran, OpenMP and MPI</title>
      <link href="/2018/10/27/Parallel%20computing%20with%20Fortran,%20OpenMP%20and%20MPI/"/>
      <url>/2018/10/27/Parallel%20computing%20with%20Fortran,%20OpenMP%20and%20MPI/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CS projects </category>
          
          <category> M3C@imperial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer science </tag>
            
            <tag> Parallel computing </tag>
            
            <tag> Fortran </tag>
            
            <tag> OpenMP </tag>
            
            <tag> MPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stochastic Differential Equation simulations and uniform peacock problem</title>
      <link href="/2018/09/27/Stochastic%20Differential%20Equation%20simulations%20and%20uniform%20peacock%20problem/"/>
      <url>/2018/09/27/Stochastic%20Differential%20Equation%20simulations%20and%20uniform%20peacock%20problem/</url>
      
        <content type="html"><![CDATA[<p>In this report we will discuss stochastic differential equations and simulations of their roots. After that, a special SDE equation will be introduced and simulated using both Euler and Milstein method.</p><p>Find full report <a href="/files/UROP.pdf">here</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Research projects </category>
          
          <category> UROP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Stochastic Differential Equations </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码分析sentry的错误信息收集</title>
      <link href="/2018/08/18/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90sentry%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2018/08/18/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90sentry%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>raven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是<code>https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js</code>。</p><p>首先抛出几个问题：</p><ul><li><strong>raven.js 是如何收集浏览器错误信息的？</strong></li><li><strong>raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？</strong></li><li><strong>面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？</strong></li><li><strong>raven.js 如何和框架配合使用（比如 vue、react）？</strong></li></ul><p>在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。</p><p>raven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：</p><ul><li><a href="https://github.com/moll/json-stringify-safe" target="_blank" rel="noopener">json-stringify-safe</a> ：一个对 <code>JSON.stringify</code> 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。<ul><li>这里面有一个注意点要单独说一下，我们熟知的 <code>JSON.stringify</code> , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 <code>json-stringify-safe</code> 就是充分利用了这三个参数。</li></ul></li><li><a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">md5</a>：js 的 md5 函数。</li><li><a href="https://github.com/csnover/TraceKit" target="_blank" rel="noopener">TraceKit</a>：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。</li></ul><p>除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。</p><h3 id="raven-js-是如何收集错误信息的？"><a href="#raven-js-是如何收集错误信息的？" class="headerlink" title="raven.js 是如何收集错误信息的？"></a>raven.js 是如何收集错误信息的？</h3><p>我们知道，在前端收集错误，肯定离不开 <code>window.onerror</code> 这个函数，那么我们就从这个函数说起。</p><p>实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function installGlobalHandler() &#123;</span><br><span class="line">  if (_onErrorHandlerInstalled) &#123; // 一个起到标志作用的全局变量</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  _oldOnerrorHandler = _window.onerror; </span><br><span class="line">  // _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖</span><br><span class="line">  // 该 _window 经过兼容，实际上就是 window</span><br><span class="line">  _window.onerror = traceKitWindowOnError;</span><br><span class="line">  _onErrorHandlerInstalled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function traceKitWindowOnError(msg, url, lineNo, colNo, ex) &#123;</span><br><span class="line"></span><br><span class="line">var exception = utils.isErrorEvent(ex) ? ex.error : ex;</span><br><span class="line">//...</span><br><span class="line">    stack = TraceKit.computeStackTrace(exception);</span><br><span class="line">    notifyHandlers(stack, true);</span><br><span class="line">    //...</span><br><span class="line">   </span><br><span class="line">    //...</span><br><span class="line">    if (_oldOnerrorHandler) &#123;</span><br><span class="line">       return _oldOnerrorHandler.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。</p><p>notifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function subscribe(handler) &#123;</span><br><span class="line">    installGlobalHandler();</span><br><span class="line">    handlers.push(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。</p><p>下面我们对错误处理 raven.js 控制的部分做了一些梳理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> _handleOnErrorStackInfo: function(stackInfo, options) &#123;</span><br><span class="line">    options.mechanism = options.mechanism || &#123;</span><br><span class="line">      type: &apos;onerror&apos;,</span><br><span class="line">      handled: false</span><br><span class="line">    &#125;;</span><br><span class="line">    // mechanism 和错误统计来源有关</span><br><span class="line"></span><br><span class="line">    if (!this._ignoreOnError) &#123;</span><br><span class="line">      this._handleStackInfo(stackInfo, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_handleStackInfo: function(stackInfo, options) &#123;</span><br><span class="line">    var frames = this._prepareFrames(stackInfo, options);</span><br><span class="line"></span><br><span class="line">    this._triggerEvent(&apos;handle&apos;, &#123;</span><br><span class="line">      stackInfo: stackInfo,</span><br><span class="line">      options: options</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this._processException(</span><br><span class="line">      stackInfo.name,</span><br><span class="line">      stackInfo.message,</span><br><span class="line">      stackInfo.url,</span><br><span class="line">      stackInfo.lineno,</span><br><span class="line">      frames,</span><br><span class="line">      options</span><br><span class="line">    );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_processException: function(type, message, fileurl, lineno, frames, options) &#123;</span><br><span class="line">    // 首先根据 message 信息判断是否是需要忽略的错误类型</span><br><span class="line">    // 然后判断出错的文件是否在黑名单中或者白名单中</span><br><span class="line">    // 接下来对错误内容进行必要的整合与转换，构造出 data 对象</span><br><span class="line">    // 最后调用上报函数</span><br><span class="line">    this._send(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_send: function(data) &#123;</span><br><span class="line"></span><br><span class="line">// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息</span><br><span class="line"></span><br><span class="line">// 交由 _sendProcessedPayload 进行进一步处理</span><br><span class="line">this._sendProcessedPayload(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_sendProcessedPayload: function(data, callback) &#123;</span><br><span class="line"></span><br><span class="line">// 对 data 增加一些必要的元信息</span><br><span class="line">// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 </span><br><span class="line">(globalOptions.transport || this._makeRequest).call(this, &#123;</span><br><span class="line">     url: url,</span><br><span class="line">     auth: auth,</span><br><span class="line">     data: data,</span><br><span class="line">     options: globalOptions,</span><br><span class="line">     onSuccess: function success() &#123;</span><br><span class="line">       </span><br><span class="line">     &#125;,</span><br><span class="line">     onError: function failure(error) &#123;</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">// 真正发起请求的函数</span><br><span class="line">_makeRequest: function(opts) &#123;</span><br><span class="line">// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求</span><br><span class="line">// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：</span><br><span class="line"></span><br><span class="line">* 每个函数只处理一件或者一些事情，保持函数的短小整洁。</span><br><span class="line">* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `try &#123;</span><br><span class="line">    doSomething(a[0])</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">    Raven.captureException(e)</span><br><span class="line">&#125;` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。</span><br><span class="line"></span><br><span class="line">但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：</span><br><span class="line"></span><br><span class="line">* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。</span><br><span class="line">* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `_processException `、`_sendProcessedPayload `、`_makeRequest `等都只在一个链路中被调用一次。</span><br><span class="line">* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。</span><br><span class="line"></span><br><span class="line">最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">Raven.config(&apos;http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2&apos;).install()</span><br><span class="line">let s = window.ss;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">    let b = s.b</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    Raven.captureException(e)</span><br><span class="line">    // sentry should report error now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.nomethod();</span><br><span class="line">// sentry should report error now</span><br></pre></td></tr></table></figure><p>以上例子中，sentry 会发送两个 POST 请求。</p><h3 id="raven-js-最终上报数据的格式"><a href="#raven-js-最终上报数据的格式" class="headerlink" title="raven.js 最终上报数据的格式"></a>raven.js 最终上报数据的格式</h3><p>这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。</p><p>我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;project&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;logger&quot;: &quot;javascript&quot;,</span><br><span class="line">  &quot;platform&quot;: &quot;javascript&quot;,</span><br><span class="line">  &quot;request&quot;: &#123;</span><br><span class="line">    &quot;headers&quot;: &#123;</span><br><span class="line">      &quot;User-Agent&quot;: &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;url&quot;: &quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exception&quot;: &#123;</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;TypeError&quot;,</span><br><span class="line">        &quot;value&quot;: &quot;Cannot read property &apos;b&apos; of undefined&quot;,</span><br><span class="line">        &quot;stacktrace&quot;: &#123;</span><br><span class="line">          &quot;frames&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;filename&quot;: &quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;,</span><br><span class="line">              &quot;lineno&quot;: 19,</span><br><span class="line">              &quot;colno&quot;: 19,</span><br><span class="line">              &quot;function&quot;: &quot;?&quot;,</span><br><span class="line">              &quot;in_app&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;mechanism&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;generic&quot;,</span><br><span class="line">      &quot;handled&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;transaction&quot;: &quot;http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu&quot;,</span><br><span class="line">  &quot;extra&quot;: &#123;</span><br><span class="line">    &quot;session:duration&quot;: 6</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;breadcrumbs&quot;: &#123;</span><br><span class="line">    &quot;values&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;timestamp&quot;: 1534257309.996,</span><br><span class="line">        &quot;message&quot;: &quot;_prepareFrames stackInfo: [object Object]&quot;,</span><br><span class="line">        &quot;level&quot;: &quot;log&quot;,</span><br><span class="line">        &quot;category&quot;: &quot;console&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      // ...</span><br><span class="line">   ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;event_id&quot;: &quot;ea0334adaf9d43b78e72da2b10e084a9&quot;,</span><br><span class="line">  &quot;trimHeadFrames&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中支持的信息类型重点分为以下几种：</p><ul><li>sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息</li><li>错误信息，主要包括错误调用栈信息</li><li>request 信息，主要包括浏览器的 User-Agent、当前请求地址等</li><li>面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍</li></ul><h3 id="raven-js-面包屑收集"><a href="#raven-js-面包屑收集" class="headerlink" title="raven.js 面包屑收集"></a>raven.js 面包屑收集</h3><p>面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。</p><p>面包屑信息主要包括这几类：</p><ul><li>用户对某个元素的点击或者用户对某个可输入元素的输入</li><li>发送的 http 请求</li><li>console 打印的信息（支持配置 ‘debug’, ‘info’, ‘warn’, ‘error’, ‘log’ 等不同级别）</li><li>window.location 变化信息</li></ul><p>接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。</p><p>实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：</p><ul><li>window.setTimeout</li><li>window.setInterval</li><li>window.requestAnimationFrame</li><li>EventTarget.addEventListener</li><li>EventTarget.removeEventListener</li><li>XMLHTTPRequest.open</li><li>XMLHTTPRequest.send</li><li>window.fetch</li><li>History.pushState</li><li>History.replaceState</li></ul><blockquote><p>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）</p></blockquote><p>接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapEventTarget</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> proto = _window[global] &amp;&amp; _window[global].prototype;</span><br><span class="line">      <span class="keyword">if</span> (proto &amp;&amp; proto.hasOwnProperty &amp;&amp; proto.hasOwnProperty(<span class="string">'addEventListener'</span>)) &#123;</span><br><span class="line">        fill(</span><br><span class="line">          proto,</span><br><span class="line">          <span class="string">'addEventListener'</span>,</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">evtName, fn, capture, secure</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fn &amp;&amp; fn.handleEvent) &#123; <span class="comment">//兼容通过 handleEvent 的方式进行绑定事件</span></span><br><span class="line">                  fn.handleEvent = self.wrap(</span><br><span class="line">                    &#123;</span><br><span class="line">                      mechanism: &#123;</span><br><span class="line">                        type: <span class="string">'instrument'</span>,</span><br><span class="line">                        data: &#123;</span><br><span class="line">                          target: global,</span><br><span class="line">                          <span class="function"><span class="keyword">function</span>: '<span class="title">handleEvent</span>',</span></span><br><span class="line"><span class="function">                          <span class="title">handler</span>: (<span class="params">fn &amp;&amp; fn.name</span>) || '&lt;<span class="title">anonymous</span>&gt;'</span></span><br><span class="line"><span class="function">                        &#125;</span></span><br><span class="line"><span class="function">                      &#125;</span></span><br><span class="line"><span class="function">                    &#125;,</span></span><br><span class="line"><span class="function">                    <span class="title">fn</span>.<span class="title">handleEvent</span></span></span><br><span class="line"><span class="function">                  );</span></span><br><span class="line"><span class="function">                &#125;</span></span><br><span class="line"><span class="function">              &#125; <span class="title">catch</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">var</span> before, clickHandler, keypressHandler;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                autoBreadcrumbs &amp;&amp;</span><br><span class="line">                autoBreadcrumbs.dom &amp;&amp;</span><br><span class="line">                (global === <span class="string">'EventTarget'</span> || global === <span class="string">'Node'</span>)</span><br><span class="line">              ) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> generating multiple handlers per addEventListener invocation, should</span></span><br><span class="line">                <span class="comment">//       revisit and verify we can just use one (almost certainly)</span></span><br><span class="line">                clickHandler = self._breadcrumbEventHandler(<span class="string">'click'</span>);</span><br><span class="line">                keypressHandler = self._keypressEventHandler();</span><br><span class="line">                before = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; <span class="comment">// 钩子函数，用于在回调函数调用的时候记录信息</span></span><br><span class="line">                  <span class="keyword">if</span> (!evt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">var</span> eventType;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    eventType = evt.type;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="comment">// just accessing event properties can throw an exception in some rare circumstances</span></span><br><span class="line">                    <span class="comment">// see: https://github.com/getsentry/raven-js/issues/838</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (eventType === <span class="string">'click'</span>) <span class="keyword">return</span> clickHandler(evt);</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (eventType === <span class="string">'keypress'</span>) <span class="keyword">return</span> keypressHandler(evt);</span><br><span class="line">                &#125;;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> orig.call(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                evtName,</span><br><span class="line">                self.wrap(</span><br><span class="line">                  &#123;</span><br><span class="line">                    mechanism: &#123;</span><br><span class="line">                      type: <span class="string">'instrument'</span>,</span><br><span class="line">                      data: &#123;</span><br><span class="line">                        target: global,</span><br><span class="line">                        <span class="function"><span class="keyword">function</span>: '<span class="title">addEventListener</span>',</span></span><br><span class="line"><span class="function">                        <span class="title">handler</span>: (<span class="params">fn &amp;&amp; fn.name</span>) || '&lt;<span class="title">anonymous</span>&gt;'</span></span><br><span class="line"><span class="function">                      &#125;</span></span><br><span class="line"><span class="function">                    &#125;</span></span><br><span class="line"><span class="function">                  &#125;,</span></span><br><span class="line"><span class="function">                  <span class="title">fn</span>,</span></span><br><span class="line"><span class="function">                  <span class="title">before</span></span></span><br><span class="line"><span class="function">                ),</span></span><br><span class="line"><span class="function">                <span class="title">capture</span>,</span></span><br><span class="line"><span class="function">                <span class="title">secure</span></span></span><br><span class="line"><span class="function">              );</span></span><br><span class="line"><span class="function">            &#125;;</span></span><br><span class="line"><span class="function">          &#125;,</span></span><br><span class="line"><span class="function">          <span class="title">wrappedBuiltIns</span></span></span><br><span class="line"><span class="function">        );</span></span><br><span class="line"><span class="function">        <span class="title">fill</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          proto,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">'removeEventListener'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">          function(orig</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">evt, fn, capture, secure</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                fn = fn &amp;&amp; (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">// ignore, accessing __raven_wrapper__ will throw in some Selenium environments</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> orig.call(<span class="keyword">this</span>, evt, fn, capture, secure);</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">          wrappedBuiltIns</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在<a href="http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/" target="_blank" rel="noopener">这里</a>补充一些相关的知识）。</p><p>默认情况下，raven.js 只记录通过 <code>EventTarget.addEventListener</code> 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。</p><h3 id="raven-js-如何和框架配合使用"><a href="#raven-js-如何和框架配合使用" class="headerlink" title="raven.js 如何和框架配合使用"></a>raven.js 如何和框架配合使用</h3><p>raven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。</p><p>raven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。</p><p>插件内容本身非常简单，我们可以看一下 vue 插件的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function formatComponentName(vm) &#123;</span><br><span class="line">  if (vm.$root === vm) &#123;</span><br><span class="line">    return &apos;root instance&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;</span><br><span class="line">  return (</span><br><span class="line">    (name ? &apos;component &lt;&apos; + name + &apos;&gt;&apos; : &apos;anonymous component&apos;) +</span><br><span class="line">    (vm._isVue &amp;&amp; vm.$options.__file ? &apos; at &apos; + vm.$options.__file : &apos;&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function vuePlugin(Raven, Vue) &#123;</span><br><span class="line">  Vue = Vue || window.Vue;</span><br><span class="line"></span><br><span class="line">  // quit if Vue isn&apos;t on the page</span><br><span class="line">  if (!Vue || !Vue.config) return;</span><br><span class="line"></span><br><span class="line">  var _oldOnError = Vue.config.errorHandler;</span><br><span class="line">  Vue.config.errorHandler = function VueErrorHandler(error, vm, info) &#123;</span><br><span class="line">    var metaData = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // vm and lifecycleHook are not always available</span><br><span class="line">    if (Object.prototype.toString.call(vm) === &apos;[object Object]&apos;) &#123;</span><br><span class="line">      metaData.componentName = formatComponentName(vm);</span><br><span class="line">      metaData.propsData = vm.$options.propsData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (typeof info !== &apos;undefined&apos;) &#123;</span><br><span class="line">      metaData.lifecycleHook = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Raven.captureException(error, &#123;</span><br><span class="line">      extra: metaData</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (typeof _oldOnError === &apos;function&apos;) &#123;</span><br><span class="line">      _oldOnError.call(this, error, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = vuePlugin;</span><br></pre></td></tr></table></figure><p>应该不用进行过多解释。</p><p>你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了<a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">Error Boundaries</a>，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考<a href="https://docs.sentry.io/clients/javascript/integrations/react/" target="_blank" rel="noopener">这里</a></p><blockquote><p>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。</p></blockquote><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lagrangian Mechanics and Rigid Body Motion</title>
      <link href="/2018/06/20/Lagrangian%20Mechanics%20and%20Heavy-top%20Motion/"/>
      <url>/2018/06/20/Lagrangian%20Mechanics%20and%20Heavy-top%20Motion/</url>
      
        <content type="html"><![CDATA[<p>This is a group research project I did in my second year at Imperial College London as a math undergraduate student. I cooperated with the team in explaining and proving basic Lagrangian Mechanics and the investigation into the heavy-top problems.</p><p>Here is an abstract of what this project is about. The full report reveals more about the proof, examples and Matlab code.</p><blockquote><p>In our report we will discuss Lagrangian Mechanics and the Motion of Rigid Bodies. La- grangian Mechanics is a reformulation of Classical Mechanics, first introduced by the famous mathematician Joseph-Louis Lagrange, in 1788. We shall discuss the uses of Lagrangian Me- chanics and include two examples - the Spherical Pendulum and the Double Pendulum. In each case we will derive the equations of motion, and then try to solve these numerically and/or analytically. We will investigate the effect of removing the gravitational field (in the case of the Spherical Pendulum) and discuss any links between the two, as well as any implications of the solutions. <br><br>A rigid body is a collection of N points such that the distance between any two of them is fixed regardless of any external forces they are subject to. We shall look at the kinematics, the Inertia Tensor and Euler’s Equation and use this to explain about the dynamical stability of rigid bodies. Symmetric tops are the main example that we will investigate and discuss. We will look into the precession rate and the spinning rate and discuss two examples, Feynman’s wobbling plate and the hula hoop. A more complicated rigid body we shall then explore is the heavy symmetric top, in which we take into account the forces exerted by a gravitational field.</p></blockquote><p>Full report is <a href="/files/M2R.pdf">here</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Research projects </category>
          
          <category> M2R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Mechanics </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇关于react历史的流水账</title>
      <link href="/2018/06/09/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8Ereact%E5%8E%86%E5%8F%B2%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
      <url>/2018/06/09/%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8Ereact%E5%8E%86%E5%8F%B2%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/</url>
      
        <content type="html"><![CDATA[<p>react 目前已经更新到 V16.3，其一路走来，日臻完善，笔者接触 react 两年有余，在这里做一个阶段性的整理，也对 react 的发展和我对 react 的学习做一个整体记录。</p><p>笔者是在 16 年初开始关注 react，而实际上那个时候 react 已经发布快三年了， 16 年初的我写页面还是主要使用 backbone.js、Jquery，并且认为，相比于纯粹使用 Jquery 的“刀耕火种”的时代，使用 backbone.js 已经足够方便并且不需要替代品了。</p><p>这篇文章会从 react 开源之初进行讲起，直到 2018 年六月。</p><h3 id="为什么是-react"><a href="#为什么是-react" class="headerlink" title="为什么是 react"></a>为什么是 react</h3><p>我们知道，react 并不是一个 MVC 框架，也并没有使用传统的前端模版，而是采用了纯 JS 编写（实际上用到了 JSX ），使用了虚拟 DOM，使用 diff 来保证 DOM 的更新效率，并且可以结合 facebook 的 Flux 架构，解决传统 MVC 模式的一些痛点。</p><p>在 react 开源之初，相关生态体系并不完善，甚至官方还在用<code>Backbone.Router</code>加 react 来开发单页面应用。</p><p>但是那个时候的 react，和现在的 react，解决的核心问题都没有变化，那就是<strong>复杂的UI渲染问题（ complex UI rendering ）</strong>，所有的它的组件化，虚拟 DOM 和 diff 算法，甚至目前提出的 Fiber、async rendering等等，都是围绕这个中心。</p><h3 id="FLUX"><a href="#FLUX" class="headerlink" title="FLUX"></a>FLUX</h3><p>在 2014 年五月左右，也就是距离 react 开源接近一年时间，react 公开了 FLUX 架构。当然，我们现在在学习的过程中，甚至都很难听到 FLUX 这个词汇了，更多的则是 redux 甚至 dva 等更上层的框架，但是目前绝大多数 react 相关的数据管理框架都受到了 FLUX 很大启发。</p><p>FLUX 和双向数据绑定的关系，我认为这里有必要援引当初官方写的一点解释（更详细的一些信息，可以看<a href="https://www.10000h.top/react_flux.pdf" target="_blank" rel="noopener">这篇文章</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To summarize, Flux works well for us because the single directional data flow makes it easy to understand and modify an application as it becomes more complicated. We found that two-way data bindings lead to cascading updates, where changing one data model led to another data model updating, making it very difficult to predict what would change as the result of a single user interaction.</span><br><span class="line"></span><br><span class="line">总而言之，Flux对我们来说效果很好，因为单向数据流可以让应用程序变得更加复杂，从而轻松理解和修改应用程序。我们发现双向数据绑定导致级联更新，其中更改一个数据模型导致另一个数据模型更新，使得很难预测单个用户交互的结果会发生什么变化。</span><br></pre></td></tr></table></figure><p>从此之后，下面这张图便多次出现在官方博客和各个网站中，相信我们也肯定见过下图：</p><p><img src="https://www.10000h.top/images/flux.png" alt></p><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><p>2014年8月，react-router 的雏形发布，在其发布之前，不少示例应用还在使用 backbone<br>.js 的 router，而 react-router 的发布，标志着 react 生态的进一步成熟。</p><h3 id="react-ES6-Class"><a href="#react-ES6-Class" class="headerlink" title="react ES6 Class"></a>react ES6 Class</h3><p>实际上，在 2015.01.27 之前，我们都是在使用 <code>React.createClass</code>来书写组件。</p><p>而在 2015.01.27 这一天，也就是第一届 <code>reactjs conf</code> 的前一天，react 官方发布了 React V0.13.0 beta 版本。这一个版本的最大更新就是支持 ES6 的 Class 写法来书写组件，同时也公布了比如 propTypes 类型检查、defaultProps、AutoBind、ref 等一系列相关工作在 ES6 Class 模式下的写法。</p><p>这次发布是 react 开源至此最为重大的一次更新，也因此直接将 react 的写法进行了革新，在我看来，这标志着 react 从刀耕火种的原始时代进入了石器时代。</p><p><em>实际上，直到一个半月后的 03.10 ，V0.13 的正式版本才发布。</em></p><p>而在之后的 V15.5 版本（2017年4月发布），react 才将<code>React.createClass</code>的使用设置为 Deprecation，并且宣布会在将来移除该 API，与此同时，react 团队仍然提供了一个单独的库<code>create-react-class</code> 来支持原来的 <code>React.createClass</code> 功能。</p><h3 id="Relay-amp-GraphQL"><a href="#Relay-amp-GraphQL" class="headerlink" title="Relay &amp; GraphQL"></a>Relay &amp; GraphQL</h3><p>在 2015 年的 2月，Facebook 公布了 GraphQL，GraphQL 是一种新的数据查询解决方案，事实证明，它是非常优秀的一个解决方案，到现在已经基本在行业内人尽皆知。</p><p>而 Relay 则是链接 react 和 GraphQL 的一个解决方案，有点类似 redux（但是 stat 数只有 redux 的四分之一左右），但是对 GraphQL 更为友好，并且在缓存机制的设计（按照 Graph 来 cache）、声明式的数据获取等方面，有一些自己的独到之处。</p><p>当然，我们使用 redux 配合相关插件，也可以不使用 Relay。</p><h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><p>在第一届 React.js Conf 中，react 团队首次公开了 React Native，并且在3月份真正开源了 React Native（实际上这个时候安卓版本还并不可用），之后在2015年上半年，相关团队陆陆续续披露了关于 React Native 发展情况的更多信息。</p><p>并且也是在这个时候（2015年3月），react 团队开始使用 <strong>learn once, write anywhere</strong> 这个如今我们耳熟能详的口号。</p><h3 id="react-amp-react-dom-amp-babel"><a href="#react-amp-react-dom-amp-babel" class="headerlink" title="react &amp; react-dom &amp; babel"></a>react &amp; react-dom &amp; babel</h3><p>在2015年七月，官方发布了React v0.14 Beta 1，这也是一个变动比较大的版本，在这个版本中，主要有如下比较大的变化:</p><ul><li>官方宣布废弃 react-tools 和 JSTransform，这是和 JSX 解析相关的库，而从此 react 开始使用 babel，我认为这对 react 以及其使用者来说无疑是一个利好。</li><li>分离 react 和 react-dom，由于 React Native 已经迭代了一段时间，这个分离同时也意味着 react 之后的发展方向，react 本身将会关注抽象层和组件本身，而 react-dom 可以将其在浏览器中落地，React Native 可以将其在客户端中落地，之后也许还会有 react-xxx …</li></ul><p>将 react 和 react-dom 分离之后，react 团队又对 react-dom 在 dom 方面做了较为大量的更新。</p><h3 id="Discontinuing-IE-8-Support"><a href="#Discontinuing-IE-8-Support" class="headerlink" title="Discontinuing IE 8 Support"></a>Discontinuing IE 8 Support</h3><p>在 react V15 的版本中，放弃了对 IE 8 的支持。</p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><p>react 团队使用 Fiber 架构完成了 react V16 的开发，得益于 Fiber 架构，react 的性能又得到了显著提升（尤其是在某些要求交互连续的场景下），并且包大小缩小了 32%。</p><p>到目前来说，关于 Fiber 架构的中英文资料都已经相当丰富，笔者在这里就不进行过多的赘述了。</p><h3 id="接下来的展望"><a href="#接下来的展望" class="headerlink" title="接下来的展望"></a>接下来的展望</h3><p>react 团队目前的主要工作集中在 async rendering 方面，这方面的改进可以极大提升用户交互体验（特别是在弱网络环境下），会在 2018 年发布。</p><p>如果你对这方面的内容很感兴趣，不妨看看 react 之前的<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">演讲视频</a></p><h3 id="附录1-一些你可能不知道的变化"><a href="#附录1-一些你可能不知道的变化" class="headerlink" title="附录1 一些你可能不知道的变化"></a>附录1 一些你可能不知道的变化</h3><ul><li>react并非直接将 JSX 渲染成 DOM，而是对某些事件和属性做了封装（优化）。 react 对表单类型的 DOM 进行了优化，比如封装了较为通用的 onChange 回调函数，这其中需要处理不少问题，react 在 V0.4 即拥有了这一特性，可以参考<a href="https://reactjs.org/blog/2013/07/23/community-roundup-5.html#cross-browser-onchange" target="_blank" rel="noopener">这里</a></li><li>事实上，react 在V0.8之前，一直在以“react-tools”这个名字发布，而 npm 上面叫做 react 的实际上是另外一个包，而到 V0.8 的时候，react 团队和原来的 “react” 包开发者协商，之后 react 便接管了原来的这个包，也因此，react并没有 V0.6 和 V0.7，而是从 V0.5 直接到了 V0.8</li><li>react 从 V0.14 之后，就直接跳跃到了 V15，官方团队给出的理由是，react 很早就已经足够稳定并且可以使用在生产版本中，更改版本的表达方式更有助于表示 react 项目本身的稳定性。</li></ul><h3 id="附录2-一些比较优秀的博客"><a href="#附录2-一些比较优秀的博客" class="headerlink" title="附录2 一些比较优秀的博客"></a>附录2 一些比较优秀的博客</h3><ul><li>关于React Components, Elements, 和 Instances，如果你还有一些疑问，可以看一看React官方团队的文章：<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">React Components, Elements, and Instances</a></li><li>如果你倾向于使用 mixins，不妨看看 react 关于取消 mixin的说法：<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a></li><li>react props 相关的开发模式的建议，我认为目前在使用 react 的程序员都应该了解一下<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">You Probably Don’t Need Derived State</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十条编写优化的 JavaScript 代码的建议</title>
      <link href="/2018/05/29/%E5%8D%81%E6%9D%A1%E7%BC%96%E5%86%99%E4%BC%98%E5%8C%96%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
      <url>/2018/05/29/%E5%8D%81%E6%9D%A1%E7%BC%96%E5%86%99%E4%BC%98%E5%8C%96%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>本文总结了十条编写优秀的 JavaScript 代码的习惯，主要针对 V8 引擎：</p><p>1.始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。V8 在对 js 代码解析的时候会有构建隐藏类的过程，以相同的顺序实例化（属性赋值）的对象会共享相同的隐藏类。下面给出一个不好的实践：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p1.a = <span class="number">5</span>;</span><br><span class="line">p1.b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p2.b = <span class="number">7</span>;</span><br><span class="line">p2.a = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 由于 a 和 b 的赋值顺序不同，p1 和 p2 无法共享隐藏类</span></span><br></pre></td></tr></table></figure><p>2.避免分配动态属性。在实例化之后向对象添加属性将强制隐藏类更改，并减慢为先前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性。  </p><p>3.重复执行相同方法的代码将比仅执行一次（由于内联缓存）执行许多不同方法的代码运行得更快。  </p><p>4.避免创建稀疏数组。稀疏数组由于不是所有的元素都存在，因此是一个哈希表，因此访问稀疏数组中的元素代价更高。另外，尽量不要采用预分配数量的大数组，更好的办法是随着你的需要把它的容量增大。最后，尽量不要删除数组中的元素，它会让数组变得稀疏。  </p><p>5.标记值：V8采用32位来表示对象和数字，其中用一位来区别对象（flag = 0）或数字（flag = 1），因此这被称之为 SMI (Small Integer)因为它只有31位。因此，如果一个数字大于31位，V8需要对其进行包装，将其变成双精度并且用一个对象来封装它，因此应该尽量使用31位有符号数字从而避免昂贵的封装操作。  </p><p>6.检查你的依赖，去掉不需要 import 的内容。  </p><p>7.将你的代码分割成一些小的 chunks ，而不是整个引入。 </p><p>8.尽可能使用 defer 来推迟加载 JavaScript，另外只加载当前路由需要的代码段。</p><p>9.使用 dev tools 和 DeviceTiming 来寻找代码瓶颈。  </p><p>10.使用诸如Optimize.js这样的工具来帮助解析器决定何时需要提前解析以及何时需要延后解析。  </p><p>以上内容来源：</p><ul><li><a href="https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8" target="_blank" rel="noopener">How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time</a></li><li><a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端中的二进制数据类型</title>
      <link href="/2018/05/08/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/08/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。</p></blockquote><p>本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考<a href="http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4" target="_blank" rel="noopener">这里</a>而非本人原创，仅做个人学习使用。</p><p>这些类型化对象，一般会在以下场景中使用：</p><ul><li>WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。</li><li>在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。</li><li>在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。</li><li>在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。</li><li>在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。</li></ul><p>下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。</p><h3 id="二进制数据类型概述"><a href="#二进制数据类型概述" class="headerlink" title="二进制数据类型概述"></a>二进制数据类型概述</h3><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p><p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(32);</span><br></pre></td></tr></table></figure><p>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p><p>为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(32);</span><br><span class="line">var dataView = new DataView(buf);</span><br><span class="line">dataView.getUint8(0) // 0</span><br></pre></td></tr></table></figure><p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p><p>另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(12);</span><br><span class="line"></span><br><span class="line">var x1 = new Int32Array(buffer);</span><br><span class="line">x1[0] = 1;</span><br><span class="line">var x2 = new Uint8Array(buffer);</span><br><span class="line">x2[0]  = 2;</span><br><span class="line"></span><br><span class="line">x1[0] // 2</span><br></pre></td></tr></table></figure><p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(32);</span><br><span class="line">buffer.byteLength</span><br><span class="line">// 32</span><br></pre></td></tr></table></figure><p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (buffer.byteLength === n) &#123;</span><br><span class="line">  // 成功</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(8);</span><br><span class="line">var newBuffer = buffer.slice(0, 3);</span><br></pre></td></tr></table></figure><p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p><p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p><p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p><p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(8);</span><br><span class="line">ArrayBuffer.isView(buffer) // false</span><br><span class="line"></span><br><span class="line">var v = new Int32Array(buffer);</span><br><span class="line">ArrayBuffer.isView(v) // true</span><br></pre></td></tr></table></figure><h4 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h4><p>目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。</p><ul><li>Int8Array：8位有符号整数，长度1个字节。</li><li>Uint8Array：8位无符号整数，长度1个字节。</li><li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li><li>Int16Array：16位有符号整数，长度2个字节。</li><li>Uint16Array：16位无符号整数，长度2个字节。</li><li>Int32Array：32位有符号整数，长度4个字节。</li><li>Uint32Array：32位无符号整数，长度4个字节。</li><li>Float32Array：32位浮点数，长度4个字节。</li><li>Float64Array：64位浮点数，长度8个字节。</li></ul><p>这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。</p><ul><li>TypedArray数组的所有成员，都是同一种类型和格式。</li><li>TypedArray数组的成员是连续的，不会有空位。</li><li>Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。</li><li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li></ul><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。</p><p>构造函数有多种用法。</p><ul><li>TypedArray(buffer, byteOffset=0, length?)</li></ul><p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个8字节的ArrayBuffer</span><br><span class="line">var b = new ArrayBuffer(8);</span><br><span class="line"></span><br><span class="line">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span><br><span class="line">var v1 = new Int32Array(b);</span><br><span class="line"></span><br><span class="line">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span><br><span class="line">var v2 = new Uint8Array(b, 2);</span><br><span class="line"></span><br><span class="line">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span><br><span class="line">var v3 = new Int16Array(b, 2, 2);</span><br></pre></td></tr></table></figure><p>对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p><p>注意，byteOffset必须与所要建立的数据类型一致，否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(8);</span><br><span class="line">var i16 = new Int16Array(buffer, 1);</span><br><span class="line">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span><br></pre></td></tr></table></figure><p>上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。</p><p>如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。</p><ul><li>TypedArray(length)</li></ul><p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f64a = new Float64Array(8);</span><br><span class="line">f64a[0] = 10;</span><br><span class="line">f64a[1] = 20;</span><br><span class="line">f64a[2] = f64a[0] + f64a[1];</span><br></pre></td></tr></table></figure><ul><li>TypedArray(typedArray)</li></ul><p>类型化数组的构造函数，可以接受另一个视图实例作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var typedArray = new Int8Array(new Uint8Array(4));</span><br></pre></td></tr></table></figure><p>上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p><p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = new Int8Array([1, 1]);</span><br><span class="line">var y = new Int8Array(x);</span><br><span class="line">x[0] // 1</span><br><span class="line">y[0] // 1</span><br><span class="line"></span><br><span class="line">x[0] = 2;</span><br><span class="line">y[0] // 1</span><br></pre></td></tr></table></figure><p>上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。</p><p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = new Int8Array([1, 1]);</span><br><span class="line">var y = new Int8Array(x.buffer);</span><br><span class="line">x[0] // 1</span><br><span class="line">y[0] // 1</span><br><span class="line"></span><br><span class="line">x[0] = 2;</span><br><span class="line">y[0] // 2</span><br></pre></td></tr></table></figure><ul><li>TypedArray(arrayLikeObject)</li></ul><p>构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var typedArray = new Uint8Array([1, 2, 3, 4]);</span><br></pre></td></tr></table></figure><p>注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p><p>上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。</p><p>TypedArray数组也可以转换回普通数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var normalArray = Array.prototype.slice.call(typedArray);</span><br></pre></td></tr></table></figure><h5 id="BYTES-PER-ELEMENT属性"><a href="#BYTES-PER-ELEMENT属性" class="headerlink" title="BYTES_PER_ELEMENT属性"></a>BYTES_PER_ELEMENT属性</h5><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Int8Array.BYTES_PER_ELEMENT // 1</span><br><span class="line">Uint8Array.BYTES_PER_ELEMENT // 1</span><br><span class="line">Int16Array.BYTES_PER_ELEMENT // 2</span><br><span class="line">Uint16Array.BYTES_PER_ELEMENT // 2</span><br><span class="line">Int32Array.BYTES_PER_ELEMENT // 4</span><br><span class="line">Uint32Array.BYTES_PER_ELEMENT // 4</span><br><span class="line">Float32Array.BYTES_PER_ELEMENT // 4</span><br><span class="line">Float64Array.BYTES_PER_ELEMENT // 8</span><br></pre></td></tr></table></figure><h5 id="ArrayBuffer与字符串的互相转换"><a href="#ArrayBuffer与字符串的互相转换" class="headerlink" title="ArrayBuffer与字符串的互相转换"></a>ArrayBuffer与字符串的互相转换</h5><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span><br><span class="line">function ab2str(buf) &#123;</span><br><span class="line">  return String.fromCharCode.apply(null, new Uint16Array(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串转为ArrayBuffer对象，参数为字符串</span><br><span class="line">function str2ab(str) &#123;</span><br><span class="line">  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节</span><br><span class="line">  var bufView = new Uint16Array(buf);</span><br><span class="line">  for (var i = 0, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class="line">    bufView[i] = str.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TypedArray-prototype-set"><a href="#TypedArray-prototype-set" class="headerlink" title="TypedArray.prototype.set()"></a>TypedArray.prototype.set()</h5><p>TypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Uint8Array(8);</span><br><span class="line">var b = new Uint8Array(8);</span><br><span class="line"></span><br><span class="line">b.set(a);</span><br></pre></td></tr></table></figure><p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Uint16Array(8);</span><br><span class="line">var b = new Uint16Array(10);</span><br><span class="line"></span><br><span class="line">b.set(a, 2)</span><br></pre></td></tr></table></figure><p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p><h5 id="TypedArray-prototype-subarray"><a href="#TypedArray-prototype-subarray" class="headerlink" title="TypedArray.prototype.subarray()"></a>TypedArray.prototype.subarray()</h5><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = new Uint16Array(8);</span><br><span class="line">var b = a.subarray(2,3);</span><br><span class="line"></span><br><span class="line">a.byteLength // 16</span><br><span class="line">b.byteLength // 2</span><br></pre></td></tr></table></figure><p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p><h5 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a>TypedArray.prototype.slice()</h5><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ui8 = Uint8Array.of(0, 1, 2);</span><br><span class="line">ui8.slice(-1)</span><br><span class="line">// Uint8Array [ 2 ]</span><br></pre></td></tr></table></figure><p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p><p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p><h5 id="TypedArray-of"><a href="#TypedArray-of" class="headerlink" title="TypedArray.of()"></a>TypedArray.of()</h5><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Float32Array.of(0.151, -8, 3.7)</span><br><span class="line">// Float32Array [ 0.151, -8, 3.7 ]</span><br></pre></td></tr></table></figure><h5 id="TypedArray-from"><a href="#TypedArray-from" class="headerlink" title="TypedArray.from()"></a>TypedArray.from()</h5><p>静态方法from接受一个<strong>可遍历的数据结构（比如数组）</strong>作为参数，返回一个基于这个结构的TypedArray实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uint16Array.from([0, 1, 2])</span><br><span class="line">// Uint16Array [ 0, 1, 2 ]</span><br></pre></td></tr></table></figure><p>这个方法还可以将一种TypedArray实例，转为另一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));</span><br><span class="line">ui16 instanceof Uint16Array // true</span><br></pre></td></tr></table></figure><p>from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Int8Array.of(127, 126, 125).map(x =&gt; 2 * x)</span><br><span class="line">// Int8Array [ -2, -4, -6 ]</span><br><span class="line"></span><br><span class="line">Int16Array.from(Int8Array.of(127, 126, 125), x =&gt; 2 * x)</span><br><span class="line">// Int16Array [ 254, 252, 250 ]</span><br></pre></td></tr></table></figure><p>上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。</p><h4 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h4><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p><p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p><p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(24);</span><br><span class="line">var dv = new DataView(buffer);</span><br></pre></td></tr></table></figure><p>DataView实例有以下属性，含义与TypedArray实例的同名方法相同。</p><ul><li>DataView.prototype.buffer：返回对应的ArrayBuffer对象</li><li>DataView.prototype.byteLength：返回占据的内存字节长度</li><li>DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始</li></ul><p>DataView实例提供8个方法读取内存。</p><ul><li>getInt8：读取1个字节，返回一个8位整数。</li><li>getUint8：读取1个字节，返回一个无符号的8位整数。</li><li>getInt16：读取2个字节，返回一个16位整数。</li><li>getUint16：读取2个字节，返回一个无符号的16位整数。</li><li>getInt32：读取4个字节，返回一个32位整数。</li><li>getUint32：读取4个字节，返回一个无符号的32位整数。</li><li>getFloat32：读取4个字节，返回一个32位浮点数。</li><li>getFloat64：读取8个字节，返回一个64位浮点数。</li></ul><p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(24);</span><br><span class="line">var dv = new DataView(buffer);</span><br><span class="line"></span><br><span class="line">// 从第1个字节读取一个8位无符号整数</span><br><span class="line">var v1 = dv.getUint8(0);</span><br><span class="line"></span><br><span class="line">// 从第2个字节读取一个16位无符号整数</span><br><span class="line">var v2 = dv.getUint16(1);</span><br><span class="line"></span><br><span class="line">// 从第4个字节读取一个16位无符号整数</span><br><span class="line">var v3 = dv.getUint16(3);</span><br></pre></td></tr></table></figure><p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p><p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 小端字节序</span><br><span class="line">var v1 = dv.getUint16(1, true);</span><br><span class="line"></span><br><span class="line">// 大端字节序</span><br><span class="line">var v2 = dv.getUint16(3, false);</span><br><span class="line"></span><br><span class="line">// 大端字节序</span><br><span class="line">var v3 = dv.getUint16(3);</span><br></pre></td></tr></table></figure><p>DataView视图提供8个方法写入内存。</p><ul><li>setInt8：写入1个字节的8位整数。</li><li>setUint8：写入1个字节的8位无符号整数。</li><li>setInt16：写入2个字节的16位整数。</li><li>setUint16：写入2个字节的16位无符号整数。</li><li>setInt32：写入4个字节的32位整数。</li><li>setUint32：写入4个字节的32位无符号整数。</li><li>setFloat32：写入4个字节的32位浮点数。</li><li>setFloat64：写入8个字节的64位浮点数。</li></ul><p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在第1个字节，以大端字节序写入值为25的32位整数</span><br><span class="line">dv.setInt32(0, 25, false);</span><br><span class="line"></span><br><span class="line">// 在第5个字节，以大端字节序写入值为25的32位整数</span><br><span class="line">dv.setInt32(4, 25);</span><br><span class="line"></span><br><span class="line">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span><br><span class="line">dv.setFloat32(8, 2.5, true);</span><br></pre></td></tr></table></figure><p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var littleEndian = (function() &#123;</span><br><span class="line">  var buffer = new ArrayBuffer(2);</span><br><span class="line">  new DataView(buffer).setInt16(0, 256, true);</span><br><span class="line">  return new Int16Array(buffer)[0] === 256;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><p>要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。</p><p>从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader();</span><br><span class="line">reader.addEventListener(&quot;loadend&quot;, function() &#123;</span><br><span class="line">   // reader.result 包含转化为类型数组的blob</span><br><span class="line">&#125;);</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure><p>更多关于Blob的内容，请直接查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">这里</a></p><h3 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h3><h4 id="String转Blob"><a href="#String转Blob" class="headerlink" title="String转Blob"></a>String转Blob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将字符串 转换成 Blob 对象</span><br><span class="line">var blob = new Blob([&quot;Hello World!&quot;], &#123;</span><br><span class="line">    type: &apos;text/plain&apos;</span><br><span class="line">&#125;);</span><br><span class="line">console.info(blob);</span><br><span class="line">console.info(blob.slice(1, 3, &apos;text/plain&apos;));</span><br></pre></td></tr></table></figure><h4 id="TypeArray转Blob"><a href="#TypeArray转Blob" class="headerlink" title="TypeArray转Blob"></a>TypeArray转Blob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//将 TypeArray  转换成 Blob 对象</span><br><span class="line">var array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);</span><br><span class="line">//测试成功</span><br><span class="line">//var blob = new Blob([array], &#123; type: &quot;application/octet-binary&quot; &#125;);</span><br><span class="line">//测试成功， 注意必须[]的包裹</span><br><span class="line">var blob = new Blob([array]);</span><br><span class="line">//将 Blob对象 读成字符串</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.readAsText(blob, &apos;utf-8&apos;);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">    console.info(reader.result); //a Hello world!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayBuffer转Blob"><a href="#ArrayBuffer转Blob" class="headerlink" title="ArrayBuffer转Blob"></a>ArrayBuffer转Blob</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer = new ArrayBuffer(32);</span><br><span class="line">var blob = new Blob([buffer]);       // 注意必须包裹[]</span><br></pre></td></tr></table></figure><h4 id="Blob转String"><a href="#Blob转String" class="headerlink" title="Blob转String"></a>Blob转String</h4><p>这里需要注意的是readAsText方法的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将字符串转换成 Blob对象</span><br><span class="line">var blob = new Blob([&apos;中文字符串&apos;], &#123;</span><br><span class="line">    type: &apos;text/plain&apos;</span><br><span class="line">&#125;);</span><br><span class="line">//将Blob 对象转换成字符串</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.readAsText(blob, &apos;utf-8&apos;);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">    console.info(reader.result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Blob转ArrayBuffer"><a href="#Blob转ArrayBuffer" class="headerlink" title="Blob转ArrayBuffer"></a>Blob转ArrayBuffer</h4><p>这里需要注意的是readAsArrayBuffer方法的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//将字符串转换成 Blob对象</span><br><span class="line">var blob = new Blob([&apos;中文字符串&apos;], &#123;</span><br><span class="line">    type: &apos;text/plain&apos;</span><br><span class="line">&#125;);</span><br><span class="line">//将Blob 对象转换成 ArrayBuffer</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">    console.info(reader.result); //ArrayBuffer &#123;&#125;</span><br><span class="line">    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span><br><span class="line">    //var buf = new int16array(reader.result);</span><br><span class="line">    //console.info(buf);</span><br><span class="line"></span><br><span class="line">    //将 ArrayBufferView  转换成Blob</span><br><span class="line">    var buf = new Uint8Array(reader.result);</span><br><span class="line">    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]</span><br><span class="line">    reader.readAsText(new Blob([buf]), &apos;utf-8&apos;);</span><br><span class="line">    reader.onload = function () &#123;</span><br><span class="line">        console.info(reader.result); //中文字符串</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //将 ArrayBufferView  转换成Blob</span><br><span class="line">    var buf = new DataView(reader.result);</span><br><span class="line">    console.info(buf); //DataView &#123;&#125;</span><br><span class="line">    reader.readAsText(new Blob([buf]), &apos;utf-8&apos;);</span><br><span class="line">    reader.onload = function () &#123;</span><br><span class="line">        console.info(reader.result); //中文字符串</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器初始化设置用户和ssh公私钥登陆</title>
      <link href="/2018/04/11/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%92%8Cssh%E5%85%AC%E7%A7%81%E9%92%A5%E7%99%BB%E9%99%86/"/>
      <url>/2018/04/11/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%92%8Cssh%E5%85%AC%E7%A7%81%E9%92%A5%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。</p></blockquote><h3 id="修改ssh端口号"><a href="#修改ssh端口号" class="headerlink" title="修改ssh端口号"></a>修改ssh端口号</h3><p>第一件事情：</p><p>修改ssh端口号： 之后加上一个端口比如说50000</p><p><code>vi /etc/ssh/sshd_config</code>之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。</p><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考<a href="https://blog.csdn.net/ul646691993/article/details/52104082" target="_blank" rel="noopener">这里</a>的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。</p><p>之后就可以通过这样的方式登录了：(注意登录方式一定要写对)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@115.29.102.81 -p 50000</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xiaotao</span><br><span class="line">passwd xiaotao</span><br></pre></td></tr></table></figure><p>可以用<code>ls -al /home/`</code>查看一下账户</p><p>对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w sudoers</span><br></pre></td></tr></table></figure><p>然后进入这个文件在这里进行更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">xiaotao  ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>然后再改回权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-w sudoers</span><br></pre></td></tr></table></figure><p>注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure><h3 id="配置公私钥加密登录"><a href="#配置公私钥加密登录" class="headerlink" title="配置公私钥加密登录"></a>配置公私钥加密登录</h3><p><strong>这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。</strong></p><p>很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。</p><p>在客户端先进到这个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>生成公钥和私钥（实际上如果之前有的话就不用重新生成了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>接下来把公钥上传到服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub xiaotao@&lt;ssh_server_ip&gt;:~</span><br></pre></td></tr></table></figure><p>在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  id_rsa.pub &gt;&gt; ～/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"># 禁用root账户登录，非必要，但为了安全性，请配置</span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line"># 是否让 sshd 去检查用户家目录或相关档案的权限数据，</span><br><span class="line"># 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。</span><br><span class="line"># 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入</span><br><span class="line">StrictModes no</span><br><span class="line"></span><br><span class="line"># 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。</span><br><span class="line"># 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile      %h/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">#有了证书登录了，就禁用密码登录吧，安全要紧</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><p>然后不要忘记 <code>sudo service sshd restart</code></p><p>一般来讲，这样就算是成功了，我们可以在客户端尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa remote_username@remote_ip</span><br></pre></td></tr></table></figure><p>如果不行，可能是服务端或客户端相关 <code>.ssh</code> 文件权限不对，可以进行如下尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务端</span><br><span class="line">chown -R 0700  ~/.ssh</span><br><span class="line">chown -R 0644  ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">客户端改一下</span><br><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建利用Proxy和Reflect实现双向数据绑定的微框架</title>
      <link href="/2018/04/08/%E6%9E%84%E5%BB%BA%E5%88%A9%E7%94%A8Proxy%E5%92%8CReflect%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%BE%AE%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/04/08/%E6%9E%84%E5%BB%BA%E5%88%A9%E7%94%A8Proxy%E5%92%8CReflect%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%BE%AE%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。</p></blockquote><p>代码下载地址：<a href="https://github.com/aircloud/Polar.js" target="_blank" rel="noopener">这里下载</a></p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p><em>关于Proxy和Reflect的资料推荐阮老师的教程:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a> 这里不做过多介绍。</em></p><p>实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。</p><p>由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。</p><p>首先我们可以看整体功能演示：<br>[一个gif动图，如果不能看，请点击<a href="https://www.10000h.top/images/data_img/gif1.gif" target="_blank" rel="noopener">这里的链接</a>]</p><p><img src="https://www.10000h.top/images/data_img/gif1.gif" alt></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。</p><p>我的思路是这样的：</p><ul><li>将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。</li><li>对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。</li><li>我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。</li></ul><p>下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;label&gt;name:&lt;/label&gt;</span><br><span class="line">        &lt;input p-model = &quot;name&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;div&gt;name:&#123;&#123;name&#125;&#125; age:&#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;i&gt;note:&#123;&#123;note&#125;&#125;&lt;/i&gt;&lt;br/&gt;</span><br><span class="line">    &lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> var myPolar = new Polar(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: &quot;niexiaotao&quot;,</span><br><span class="line">            age:16,</span><br><span class="line">            note:&quot;Student of Zhejiang University&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            test:function(e,addNumber)&#123;</span><br><span class="line">                console.log(&quot;e:&quot;,e);</span><br><span class="line">                this.data.age+=Number(addNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。</p><p>我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> constructor(configs)&#123;</span><br><span class="line">        this.root = this.el = document.querySelector(configs.el);</span><br><span class="line">        this._data = configs.data;</span><br><span class="line">        this._data.__bindings = &#123;&#125;;</span><br><span class="line">        //创建代理对象</span><br><span class="line">        this.data = new Proxy(this._data, &#123;set&#125;);</span><br><span class="line">        this.methods = configs.methods;</span><br><span class="line"></span><br><span class="line">        this._compile(this.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的<code>_compile</code>方法可以理解为一个私有的初始化方法。</p><p>实际上我把剩下的内容几乎都放在<code>_compile</code>方法里面了，这样理解起来方便，但是之后可能要改动。</p><p>我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：</p><p>假设我们这样<code>&lt;div&gt;name:&lt;/div&gt;</code>将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。</p><p>看上文的<code>__bindings</code>。这个对象用来存储所有绑定的dom节点信息，<code>__bindings</code>本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSet.__bindings[key].forEach(function(item)&#123;</span><br><span class="line">       //do something to update...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Directive(el,polar,attr,elementValue)&#123;</span><br><span class="line">    this.el=el;//元素本身dom节点</span><br><span class="line">    this.polar = polar;//对应的polar实例</span><br><span class="line">    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue</span><br><span class="line">    this.el[this.attr] = this.elementValue = elementValue;//初始化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的set可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function set(target, key, value, receiver) &#123;</span><br><span class="line">    const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">    var dataSet = receiver || target;</span><br><span class="line">    dataSet.__bindings[key].forEach(function(item)&#123;</span><br><span class="line">        item.el[item.attr] = item.elementValue = value;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可能还有一个问题：我们的<code></code>实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：<code>&lt;div&gt;name: age:&lt;/div&gt;</code>？</p><p>关于这两个问题，前者的答案是我们将<code></code>替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)</p><p>所以我们在<code>_compile</code>函数首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var _this = this;</span><br><span class="line"></span><br><span class="line">        var nodes = root.children;</span><br><span class="line"></span><br><span class="line">        var bindDataTester = new RegExp(&quot;&#123;&#123;(.*?)&#125;&#125;&quot;,&quot;ig&quot;);</span><br><span class="line"></span><br><span class="line">        for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            var node=nodes[i];</span><br><span class="line"></span><br><span class="line">            //如果还有html字节点，则递归</span><br><span class="line">            if(node.children.length)&#123;</span><br><span class="line">                this._compile(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var matches = node.innerHTML.match(bindDataTester);</span><br><span class="line">            if(matches)&#123;</span><br><span class="line">                var newMatches = matches.map(function (item) &#123;</span><br><span class="line">                    return  item.replace(/&#123;&#123;(.*?)&#125;&#125;/,&quot;$1&quot;)</span><br><span class="line">                &#125;);</span><br><span class="line">                var splitTextNodes  = node.innerHTML.split(/&#123;&#123;.*?&#125;&#125;/);</span><br><span class="line">                node.innerHTML=null;</span><br><span class="line">                //更新DOM，处理同一个textnode里面多次绑定情况</span><br><span class="line">                if(splitTextNodes[0])&#123;</span><br><span class="line">                    node.append(document.createTextNode(splitTextNodes[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                for(let ii=0;ii&lt;newMatches.length;ii++)&#123;</span><br><span class="line">                    var el = document.createTextNode(&apos;&apos;);</span><br><span class="line">                    node.appendChild(el);</span><br><span class="line">                    if(splitTextNodes[ii+1])&#123;</span><br><span class="line">                        node.append(document.createTextNode(splitTextNodes[ii+1]));</span><br><span class="line">                    &#125;</span><br><span class="line">                //对数据和dom进行绑定</span><br><span class="line">                let returnCode = !this._data.__bindings[newMatches[ii]]?</span><br><span class="line">                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,&quot;nodeValue&quot;,this.data[newMatches[ii]])]</span><br><span class="line">                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,&quot;nodeValue&quot;,this.data[newMatches[ii]]))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这样，我们的数据绑定阶段就写好了，接下来，我们处理<code>&lt;input p-model = &quot;name&quot; /&gt;</code>这样的情况。</p><p>这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(node.hasAttribute((&quot;p-model&quot;))</span><br><span class="line">                &amp;&amp; node.tagName.toLocaleUpperCase()==&quot;INPUT&quot; || node.tagName.toLocaleUpperCase()==&quot;TEXTAREA&quot;)&#123;</span><br><span class="line">                node.addEventListener(&quot;input&quot;, (function () &#123;</span><br><span class="line"></span><br><span class="line">                    var attributeValue = node.getAttribute(&quot;p-model&quot;);</span><br><span class="line"></span><br><span class="line">                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,&quot;value&quot;,_this.data[attributeValue])) ;</span><br><span class="line">                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,&quot;value&quot;,_this.data[attributeValue])];</span><br><span class="line"></span><br><span class="line">                    return function (event) &#123;</span><br><span class="line">                        _this.data[attributeValue]=event.target.value</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，上面调用了一个<code>IIFE</code>，实际绑定的函数只有返回的函数那一小部分。</p><p>最后我们处理事件的情况：<code>&lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</code></p><p>实际上这比处理<code>p-model</code>还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将<code>event</code>始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(node.hasAttribute(&quot;p-click&quot;)) &#123;</span><br><span class="line">                node.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">                    var attributeValue=node.getAttribute(&quot;p-click&quot;);</span><br><span class="line">                    var args=/\(.*\)/.exec(attributeValue);</span><br><span class="line">                    //允许参数</span><br><span class="line">                    if(args) &#123;</span><br><span class="line">                        args=args[0];</span><br><span class="line">                        attributeValue=attributeValue.replace(args,&quot;&quot;);</span><br><span class="line">                        args=args.replace(/[\(\)\&apos;\&quot;]/g,&apos;&apos;).split(&quot;,&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else args=[];</span><br><span class="line">                    return function (event) &#123;</span><br><span class="line">                        _this.methods[attributeValue].apply(_this,[event,...args]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在<a href="https://github.com/aircloud/Polar.js" target="_blank" rel="noopener">这里下载</a>。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。</p><p>一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～</p><hr><p>最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[PWA实践]serviceWorker生命周期、请求代理与通信</title>
      <link href="/2018/02/10/PWA%E5%AE%9E%E8%B7%B5-serviceWorker%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%90%86%E4%B8%8E%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/02/10/PWA%E5%AE%9E%E8%B7%B5-serviceWorker%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%90%86%E4%B8%8E%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者</p><p><strong>以下所有分析基于 Chrome V63</strong></p><h3 id="serviceWorker的挂载"><a href="#serviceWorker的挂载" class="headerlink" title="serviceWorker的挂载"></a>serviceWorker的挂载</h3><p>先来一段代码感受serviceWorker注册:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">      window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">          navigator.serviceWorker.register(&apos;/sw.js&apos;, &#123;scope: &apos;/&apos;&#125;)</span><br><span class="line">              .then(function (registration) &#123;</span><br><span class="line">                  // 注册成功</span><br><span class="line">                  console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</span><br><span class="line">              &#125;)</span><br><span class="line">              .catch(function (err) &#123;</span><br><span class="line">                  // 注册失败:(</span><br><span class="line">                  console.log(&apos;ServiceWorker registration failed: &apos;, err);</span><br><span class="line">              &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们定义在<code>/sw.js</code>里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)</p><p>如果我们在<code>sw.js</code>没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker</p><h3 id="serviceWorker更新"><a href="#serviceWorker更新" class="headerlink" title="serviceWorker更新"></a>serviceWorker更新</h3><p>我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：</p><ul><li>仅变更文件名(比如把<code>sw.js</code>变成<code>sw-v2.js</code>或者加一个hash)</li><li>仅变更文件内容(仅仅更新<code>sw.js</code>的内容，文件名不变)</li><li>同时变更：同时执行以上两条</li></ul><p>在这里，我可以很负责的告诉你，<strong>变更serviceWorker文件名绝对不是一个好的实践</strong>，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。</p><p>所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:</p><p>(<em>下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面</em>，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)</p><ul><li><p>这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。</p></li><li><p>如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成<code>waiting to activate</code>状态</p></li></ul><p>也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。</p><p>当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了<code>self.skipWaiting();</code>，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">    self.skipWaiting();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个时候，要分为以下两种情况：</p><ul><li>如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。</li><li>如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)</li></ul><p>Chrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。</p><h4 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h4><p>虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(&quot;/sw.js&quot;).then(reg =&gt; &#123;</span><br><span class="line">  reg.update();</span><br><span class="line">  // 或者 一段时间之后更新</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。</p><h4 id="install-生命周期钩子"><a href="#install-生命周期钩子" class="headerlink" title="install 生命周期钩子"></a>install 生命周期钩子</h4><p>我们一般会在 sw.js 中，添加<code>install</code>的回调，一般在回调中，我们会进行缓存处理操作，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;[sw2] serviceWorker Installed successfully&apos;, event)</span><br><span class="line"></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&apos;mysite-static-v1&apos;).then(function(cache) &#123;</span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &apos;/stylesheets/style.css&apos;,</span><br><span class="line">                &apos;/javascripts/common.39c462651d449a73b5bb.js&apos;,</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发<code>install</code>，如果之前没有， 那么在 serviceWorker 装载后会触发 <code>install</code>。</p><p>如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 <code>waiting to activate</code>，不会触发<code>install</code>，如果有变化，会触发<code>install</code>，但不会接管页面(上文中提到)。</p><h4 id="activate-生命周期钩子"><a href="#activate-生命周期钩子" class="headerlink" title="activate 生命周期钩子"></a>activate 生命周期钩子</h4><p>activate 在什么时候被触发呢？</p><p>如果当前页面没有 serviceworker ，那么会在 install 之后触发。</p><p>如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate</p><p>换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子</p><h3 id="serviceWorker-代理请求"><a href="#serviceWorker-代理请求" class="headerlink" title="serviceWorker 代理请求"></a>serviceWorker 代理请求</h3><p>serviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&apos;install&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;[sw2] serviceWorker Installed successfully&apos;, event)</span><br><span class="line"></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&apos;mysite-static-v1&apos;).then(function(cache) &#123;</span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &apos;/stylesheets/style.css&apos;,</span><br><span class="line">                &apos;/javascripts/common.39c462651d449a73b5bb.js&apos;,</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">    console.log(&apos;Handling fetch event for&apos;, event.request.url);</span><br><span class="line">    // console.log(&apos;[sw2]fetch but do nothing&apos;)</span><br><span class="line"></span><br><span class="line">    event.respondWith(</span><br><span class="line">        // caches.match() will look for a cache entry in all of the caches available to the service worker.</span><br><span class="line">        // It&apos;s an alternative to first opening a specific named cache and then matching on that.</span><br><span class="line">        caches.match(event.request).then(function(response) &#123;</span><br><span class="line">            if (response) &#123;</span><br><span class="line">                console.log(&apos;Found response in cache:&apos;, response);</span><br><span class="line"></span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            console.log(&apos;No response found in cache. About to fetch from network...&apos;);</span><br><span class="line"></span><br><span class="line">            // event.request will always have the proper mode set (&apos;cors, &apos;no-cors&apos;, etc.) so we don&apos;t</span><br><span class="line">            // have to hardcode &apos;no-cors&apos; like we do when fetch()ing in the install handler.</span><br><span class="line">            return fetch(event.request).then(function(response) &#123;</span><br><span class="line">                console.log(&apos;Response from network is:&apos;, response);</span><br><span class="line"></span><br><span class="line">                return response;</span><br><span class="line">            &#125;).catch(function(error) &#123;</span><br><span class="line">                // This catch() will handle exceptions thrown from the fetch() operation.</span><br><span class="line">                // Note that a HTTP error response (e.g. 404) will NOT trigger an exception.</span><br><span class="line">                // It will return a normal response object that has the appropriate error code set.</span><br><span class="line">                console.error(&apos;Fetching failed:&apos;, error);</span><br><span class="line"></span><br><span class="line">                throw error;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有两点要注意的：</p><p>我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：</p><p><img src="https://www.10000h.top/images/sw_1.png" alt></p><p>第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。</p><p>另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。</p><h3 id="serviceWorker-和-页面之间的通信"><a href="#serviceWorker-和-页面之间的通信" class="headerlink" title="serviceWorker 和 页面之间的通信"></a>serviceWorker 和 页面之间的通信</h3><p>serviceWorker向页面发消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sw.js:</span><br><span class="line"></span><br><span class="line">self.clients.matchAll().then(clients =&gt; &#123;</span><br><span class="line">    clients.forEach(client =&gt; &#123;</span><br><span class="line">        console.log(&apos;%c [sw message]&apos;, &apos;color:#00aa00&apos;, client)</span><br><span class="line">        client.postMessage(&quot;This message is from serviceWorker&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主页面:</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">    console.log(&apos;[Main] receive from serviceWorker:&apos;, event.data, event)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，这里面是有坑的：</p><ul><li>主界面的事件监听需要等serviceWorker注册完毕后，所以一般<code>navigator.serviceWorker.register</code>的回调到来之后再进行注册(或者延迟足够的时间)。</li><li>如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。</li></ul><p>从页面向 serviceWorker 发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主页面:</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(&apos;hello serviceWorker&apos;);</span><br><span class="line"></span><br><span class="line">sw.js:</span><br><span class="line">self.addEventListener(&apos;message&apos;, function (event) &#123;</span><br><span class="line">    console.log(&quot;[sw from main]&quot;,event.data); // 输出：&apos;sw.updatedone&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。</p><p>也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。</p><p>记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。</p><p><strong>以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浏览器web渲染与优化-续</title>
      <link href="/2017/08/31/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96-%E7%BB%AD/"/>
      <url>/2017/08/31/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96-%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p></blockquote><p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p><p>首先，一个网页的加载，需要什么工作呢？</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P1.png" alt></p><p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p><p>数据到端之后，又经过以下过程，才最终显示出来：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P2.png" alt></p><p>在这个过程中，我们怎么衡量性能呢？</p><p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P3.png" alt></p><p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p><p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p><p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p><p>那么<strong>首屏时间</strong>怎么测量呢？</p><p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p><p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p><ul><li>资源阻塞内核线程</li></ul><p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p><p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p><p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p><ul><li>中文Layout的时间过长</li></ul><p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p><p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p><ul><li>首次渲染太慢</li></ul><p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p><ul><li>一次解析内容过多</li></ul><p>采用首屏探测机制，优先解析首屏内容。</p><p>另外，这里可以前端配合去做首屏优化：</p><p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=‘x5-pagetype’ content=‘optpage&apos;&gt;</span><br></pre></td></tr></table></figure><p>然后在首屏分界的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;first-screen/&gt;</span><br></pre></td></tr></table></figure><p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p><p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p><ul><li>预先操作</li></ul><p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p><ul><li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li><li>经常访问的站点可以预解析DNS</li><li>点击地址栏时进行搜索预连接</li><li>点击链接时，先预链接，再做跳转。</li><li>……</li></ul><h3 id="其他方式优化"><a href="#其他方式优化" class="headerlink" title="其他方式优化"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p><h5 id="后台提速"><a href="#后台提速" class="headerlink" title="后台提速"></a>后台提速</h5><ul><li>直接使用IP，节省dns的查询时间</li><li>维持长连接</li><li>HTTP1.1启用包头节省</li><li>服务器缓存</li><li>文本资源压缩传输GZIP(6)</li><li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li></ul><h5 id="降低网络时延"><a href="#降低网络时延" class="headerlink" title="降低网络时延"></a>降低网络时延</h5><ul><li>就快接入和就近接入</li></ul><p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p><p>相比较而言，选择就快接入，是一个能够提效的方式。</p><h5 id="内容防劫持"><a href="#内容防劫持" class="headerlink" title="内容防劫持"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p><h4 id="QUIC和http2"><a href="#QUIC和http2" class="headerlink" title="QUIC和http2"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p><ul><li>延迟少</li><li>前向纠错</li><li>没有<strong>线头阻塞[注1]</strong>的多路复用</li><li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li></ul><p>——————</p><p>注1：线头阻塞：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/P4.png" alt></p><p>——————</p><p>附1: 带宽和延迟对网页加载的影响：</p><p><img src="https://www.10000h.top/images/data_img/webRender2/X1.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浏览器web渲染与优化</title>
      <link href="/2017/08/27/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2017/08/27/%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8web%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p></blockquote><p>文章主要分为以下几个部分：</p><ul><li>blink内核的渲染机制</li><li>chrome内核架构变迁</li><li>分层渲染</li><li>动画 &amp; canvas &amp; WebGl</li></ul><p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p><h3 id="blink内核的渲染机制"><a href="#blink内核的渲染机制" class="headerlink" title="blink内核的渲染机制"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p><p>一个页面的显示，实际上主要经历了下面的四个流程：</p><p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p><p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p><p><img src="https://www.10000h.top/images/data_img/webRender/P6.PNG" alt></p><p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p><ul><li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li><li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li><li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li></ul><p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p><p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p><p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p><ul><li>硬件加速合成上屏</li><li>2D Canvas、Video的硬件加速</li><li>GPU光栅化<ul><li>GPU光栅化速度更快，内存和CPU的消耗更少</li><li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li><li>GPU光栅化是未来趋势</li></ul></li></ul><h3 id="chrome内核架构变迁"><a href="#chrome内核架构变迁" class="headerlink" title="chrome内核架构变迁"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P1.PNG" alt></p><p>早期的chrome的架构实际上有以下缺点：</p><ul><li>Renderer线程任务繁重</li><li>无法实时响应缩放滑动操作</li><li>脏区域与滑动重绘区域有冲突<ul><li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li></ul></li></ul><p>当然，经过一系列的发展，Chrome现在是这样的：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P2.PNG" alt></p><p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p><p><img src="https://www.10000h.top/images/data_img/webRender/P3.PNG" alt></p><p>当然，这种架构也有如下缺点：</p><ul><li>UI线程过于繁忙</li><li>无法支持Canvas的硬件加速以及WebGL</li></ul><p>所以，后期发展成了这样：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P4.PNG" alt></p><p>总结看来，内核发展的趋势是：</p><ul><li>多线程化(可以充分利用多核心CPU)</li><li>硬件加速(可以利用GPU)</li></ul><h3 id="分层渲染"><a href="#分层渲染" class="headerlink" title="分层渲染"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p><blockquote><p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p></blockquote><p>网页的分层渲染流程主要是下面这样的：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P7.PNG" alt></p><p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p><p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p><ul><li>减少不必要的重新绘制</li><li>可以实现较为复杂的动画</li><li>能够方便实现复杂的CSS样式</li></ul><p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p><ul><li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li><li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li><li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li></ul><p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注:Chrome中符合创建新层的情况：</span><br><span class="line">Layer has 3D or perspective transform CSS properties(有3D元素的属性)</span><br><span class="line">Layer is used by &lt;video&gt; element using accelerated video decoding(video标签并使用加速视频解码)</span><br><span class="line">Layer is used by a &lt;canvas&gt; element with a 3D context or accelerated 2D context(canvas元素并启用3D)</span><br><span class="line">Layer is used for a composited plugin(插件，比如flash)</span><br><span class="line">Layer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)</span><br><span class="line">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class="line">Layer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)</span><br><span class="line">Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)</span><br></pre></td></tr></table></figure><p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p><ul><li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li><li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li><li>较长较大的页面注意总的分层个数</li><li>避免某一块区域分层过多，面积过大</li></ul><p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p><p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p><p>最后再提出一个小问题：</p><p>以下哪种渲染方式是最优的呢？</p><p><img src="https://www.10000h.top/images/data_img/webRender/P8.PNG" alt></p><p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p><h3 id="动画-amp-canvas-amp-WebGl"><a href="#动画-amp-canvas-amp-WebGl" class="headerlink" title="动画 &amp; canvas &amp; WebGl"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p><p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P9.PNG" alt></p><p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p><p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p><ul><li>cursor</li><li>font-variant</li><li>opacity</li><li>orphans</li><li>perspective</li><li>perspecti-origin</li><li>pointer-events</li><li>transform</li><li>transform-style</li><li>widows</li></ul><p>想要了解更多内容，可以参考<a href="https://csstriggers.com/" target="_blank" rel="noopener">这里</a></p><p>这方面最终的建议参考如下：</p><ul><li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li><li>动画一定要避免触发大量元素重新排版或者大面积重绘</li><li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li></ul><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P11.PNG" alt></p><h3 id="3D-canvas"><a href="#3D-canvas" class="headerlink" title="3D canvas"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p><p>这个时候该怎么办呢？</p><p>2D canvas上场。 </p><p>和CSS动画相比，2D canvas的优点是这样的：</p><ul><li>硬件加速渲染</li><li>渲染流程更优</li></ul><p>其渲染流程如下：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P10.PNG" alt></p><p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p><p>HTML 2D canvas 主要绘制如下三种元素：</p><ul><li>图片</li><li>文字</li><li>矢量</li></ul><p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P12.PNG" alt></p><p>硬件加速文字绘制的主要流程：</p><p><img src="https://www.10000h.top/images/data_img/webRender/P13.PNG" alt></p><p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p><p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p><p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p><h3 id="3D-canvas-WebGL"><a href="#3D-canvas-WebGL" class="headerlink" title="3D canvas(WebGL)"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p><ul><li>通用引擎：threeJS、Pixi</li><li>VR视频的专业引擎：krpano、UtoVR</li><li>H5游戏引擎：Egret、Layabox、Cocos</li></ul><p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p><p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p><hr><p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p><p>其他优质好文：</p><p><a href="http://qingbob.com/javascript-high-performance-animation-and-page-rendering/" target="_blank" rel="noopener">Javascript高性能动画与页面渲染</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
